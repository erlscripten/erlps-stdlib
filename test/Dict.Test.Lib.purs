module Dict.Test.Lib(erlps__new__2) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.0.2
-}

import Prelude
import Data.Array as DA
import Data.List as DL
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as Tup
import Data.BigInt as DBI
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers as H
import Erlang.Exception as EXC
import Erlang.Type (ErlangFun, ErlangTerm(..), weakCmp, weakEq,
                    weakNEq, weakLt, weakLeq, weakGeq, weakGt)
import Effect (Effect)
import Effect.Unsafe (unsafePerformEffect)
import Effect.Exception (throw)
import Partial.Unsafe (unsafePartial)


erlps__new__2 :: ErlangFun
erlps__new__2 [mod_0, eq_1] =
  (ErlangFun 2
     let
       lambda_2 [(ErlangAtom "enter"), (ErlangTuple [k_5, v_6, d_7])] =
         (erlps__enter__4 [mod_0, k_5, v_6, d_7])
       lambda_2 [(ErlangAtom "empty"), (ErlangEmptyList)] =
         (erlps__empty__1 [mod_0])
       lambda_2 [(ErlangAtom "equal"), (ErlangTuple [d1_13, d2_14])] =
         (BIF.erlang__apply__2
            [eq_1, (ErlangCons d1_13 (ErlangCons d2_14 ErlangEmptyList))])
       lambda_2 [(ErlangAtom "from_list"), l_18] =
         (erlps__from_list__2 [mod_0, l_18])
       lambda_2 [(ErlangAtom "module"), (ErlangEmptyList)] = mod_0
       lambda_2 [(ErlangAtom "size"), d_21] =
         (BIF.erlang__apply__3
            [mod_0, (ErlangAtom "size"), (ErlangCons d_21 ErlangEmptyList)])
       lambda_2 [(ErlangAtom "is_empty"), d_27] =
         (BIF.erlang__apply__3
            [mod_0, (ErlangAtom "is_empty"),
             (ErlangCons d_27 ErlangEmptyList)])
       lambda_2 [(ErlangAtom "iterator"), s_33] =
         (BIF.erlang__apply__3
            [mod_0, (ErlangAtom "iterator"),
             (ErlangCons s_33 ErlangEmptyList)])
       lambda_2 [(ErlangAtom "iterator_from"),
                 (ErlangTuple [start_39, s_40])]
         =
         (BIF.erlang__apply__3
            [mod_0, (ErlangAtom "iterator_from"),
             (ErlangCons start_39 (ErlangCons s_40 ErlangEmptyList))])
       lambda_2 [(ErlangAtom "next"), i_48] =
         (BIF.erlang__apply__3
            [mod_0, (ErlangAtom "next"), (ErlangCons i_48 ErlangEmptyList)])
       lambda_2 [(ErlangAtom "to_list"), d_54] =
         (erlps__to_list__2 [mod_0, d_54])
       lambda_2 [(ErlangAtom "erase"), (ErlangTuple [k_57, d_58])] =
         (erlps__erase__3 [mod_0, k_57, d_58])
       lambda_2 [(ErlangAtom "take"), (ErlangTuple [k_62, d_63])] =
         (erlps__take__3 [mod_0, k_62, d_63])
       lambda_2 [arg_3, arg_4] = (EXC.function_clause unit)
       lambda_2 args = (EXC.badarity (ErlangFun 2 lambda_2) args)
     in lambda_2)
erlps__new__2 [arg_67, arg_68] = (EXC.function_clause unit)
erlps__new__2 args =
  (EXC.badarity
     (ErlangFun 2 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__empty__1 :: ErlangFun
erlps__empty__1 [mod_0] =
  let match_expr_3 = (BIF.code__ensure_loaded__1 [mod_0])
  in
    case match_expr_3 of
      (ErlangTuple [(ErlangAtom "module"), mod_2]) | (mod_2 ==
                                                        mod_0) ->
        let
          case_4 =
            (BIF.erlang__function_exported__3
               [mod_0, (ErlangAtom "new"), (ErlangInt (DBI.fromInt 0))])
        in
          case case_4 of
            (ErlangAtom "false") ->
              (BIF.erlang__apply__3
                 [mod_0, (ErlangAtom "empty"), ErlangEmptyList])
            (ErlangAtom "true") ->
              (BIF.erlang__apply__3
                 [mod_0, (ErlangAtom "new"), ErlangEmptyList])
            something_else -> (EXC.case_clause something_else)
      _ -> (EXC.badmatch match_expr_3)
erlps__empty__1 [arg_14] = (EXC.function_clause unit)
erlps__empty__1 args =
  (EXC.badarity
     (ErlangFun 1 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__to_list__2 :: ErlangFun
erlps__to_list__2 [mod_0, d_1] =
  (BIF.erlang__apply__3
     [mod_0, (ErlangAtom "to_list"),
      (ErlangCons d_1 ErlangEmptyList)])
erlps__to_list__2 [arg_7, arg_8] = (EXC.function_clause unit)
erlps__to_list__2 args =
  (EXC.badarity
     (ErlangFun 2 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__from_list__2 :: ErlangFun
erlps__from_list__2 [mod_0, l_1] =
  let match_expr_4 = (BIF.code__ensure_loaded__1 [mod_0])
  in
    case match_expr_4 of
      (ErlangTuple [(ErlangAtom "module"), mod_3]) | (mod_3 ==
                                                        mod_0) ->
        let
          case_5 =
            (BIF.erlang__function_exported__3
               [mod_0, (ErlangAtom "from_orddict"),
                (ErlangInt (DBI.fromInt 1))])
        in
          case case_5 of
            (ErlangAtom "false") ->
              (BIF.erlang__apply__3
                 [mod_0, (ErlangAtom "from_list"),
                  (ErlangCons l_1 ErlangEmptyList)])
            (ErlangAtom "true") ->
              let
                orddict_15 =
                  (BIF.do_remote_fun_call "Orddict" "erlps__from_list__1" [l_1])
              in
                (BIF.erlang__apply__3
                   [mod_0, (ErlangAtom "from_orddict"),
                    (ErlangCons orddict_15 ErlangEmptyList)])
            something_else -> (EXC.case_clause something_else)
      _ -> (EXC.badmatch match_expr_4)
erlps__from_list__2 [arg_21, arg_22] = (EXC.function_clause unit)
erlps__from_list__2 args =
  (EXC.badarity
     (ErlangFun 2 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__enter__4 :: ErlangFun
erlps__enter__4 [mod_0, key_1, val_2, dict_3] =
  let match_expr_6 = (BIF.code__ensure_loaded__1 [mod_0])
  in
    case match_expr_6 of
      (ErlangTuple [(ErlangAtom "module"), mod_5]) | (mod_5 ==
                                                        mod_0) ->
        let
          case_7 =
            (BIF.erlang__function_exported__3
               [mod_0, (ErlangAtom "store"), (ErlangInt (DBI.fromInt 3))])
        in
          case case_7 of
            (ErlangAtom "false") ->
              (BIF.erlang__apply__3
                 [mod_0, (ErlangAtom "enter"),
                  (ErlangCons key_1
                     (ErlangCons val_2 (ErlangCons dict_3 ErlangEmptyList)))])
            (ErlangAtom "true") ->
              (BIF.erlang__apply__3
                 [mod_0, (ErlangAtom "store"),
                  (ErlangCons key_1
                     (ErlangCons val_2 (ErlangCons dict_3 ErlangEmptyList)))])
            something_else -> (EXC.case_clause something_else)
      _ -> (EXC.badmatch match_expr_6)
erlps__enter__4 [arg_29, arg_30, arg_31, arg_32] =
  (EXC.function_clause unit)
erlps__enter__4 args =
  (EXC.badarity
     (ErlangFun 4 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__erase__3 :: ErlangFun
erlps__erase__3 [mod_0, key_1, val_2]
  | ((ErlangAtom "true") ==
       (H.falsifyErrors
          (\ _ ->
             let
               lop_10 = (BIF.erlang__op_exactEq [mod_0, (ErlangAtom "dict")])
             in
               case lop_10 of
                 (ErlangAtom "true") -> (ErlangAtom "true")
                 (ErlangAtom "false") ->
                   (BIF.erlang__op_exactEq [mod_0, (ErlangAtom "orddict")])
                 _ -> (EXC.badarg1 lop_10)))) =
  (BIF.erlang__apply__3
     [mod_0, (ErlangAtom "erase"),
      (ErlangCons key_1 (ErlangCons val_2 ErlangEmptyList))])
erlps__erase__3 [(ErlangAtom "gb_trees"), key_0, val_1] =
  (BIF.do_remote_fun_call "Gb.Trees" "erlps__delete_any__2"
     [key_0, val_1])
erlps__erase__3 [arg_4, arg_5, arg_6] =
  (EXC.function_clause unit)
erlps__erase__3 args =
  (EXC.badarity
     (ErlangFun 3 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)

erlps__take__3 :: ErlangFun
erlps__take__3 [(ErlangAtom "gb_trees"), key_0, val_1] =
  let   
    res_7 =
      (EXC.tryCatch
         (\ _ ->
            (BIF.do_remote_fun_call "Gb.Trees" "erlps__take__2"
               [key_0, val_1]))
         (\ ex_5 ->
            case ex_5 of
              (ErlangTuple [(ErlangAtom "error"), _, _]) ->
                (ErlangAtom "error")
              ex_6 -> (EXC.raise ex_6)))
  in let
    match_final_8_11 =
      (BIF.do_remote_fun_call "Gb.Trees" "erlps__take_any__2"
         [key_0, val_1])
  in
    case match_final_8_11 of
      res_12 | (res_12 == res_7) -> match_final_8_11
      _ -> (EXC.badmatch match_final_8_11)
erlps__take__3 [mod_0, key_1, val_2] =
  (BIF.erlang__apply__3
     [mod_0, (ErlangAtom "take"),
      (ErlangCons key_1 (ErlangCons val_2 ErlangEmptyList))])
erlps__take__3 [arg_10, arg_11, arg_12] =
  (EXC.function_clause unit)
erlps__take__3 args =
  (EXC.badarity
     (ErlangFun 3 (\ _ -> (ErlangAtom "purs_tco_sucks"))) args)