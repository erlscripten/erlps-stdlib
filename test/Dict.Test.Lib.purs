module Dict.Test.Lib(erlps__new__2) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__new__2 :: ErlangFun
erlps__new__2 [mod_0, eq_1] =
  ErlangFun 2
    (let
       lambda_2 [(ErlangAtom "enter"), (ErlangTuple [k_5, v_6, d_7])] =
         erlps__enter__4 [mod_0, k_5, v_6, d_7]
       lambda_2 [(ErlangAtom "empty"), (ErlangEmptyList)] =
         erlps__empty__1 [mod_0]
       lambda_2 [(ErlangAtom "equal"), (ErlangTuple [d1_13, d2_14])] =
         BIF.erlang__apply__2
           [eq_1, ErlangCons d1_13 (ErlangCons d2_14 ErlangEmptyList)]
       lambda_2 [(ErlangAtom "from_list"), l_18] =
         erlps__from_list__2 [mod_0, l_18]
       lambda_2 [(ErlangAtom "module"), (ErlangEmptyList)] = mod_0
       lambda_2 [(ErlangAtom "size"), d_21] =
         BIF.erlang__apply__3
           [mod_0, ErlangAtom "size", ErlangCons d_21 ErlangEmptyList]
       lambda_2 [(ErlangAtom "is_empty"), d_27] =
         BIF.erlang__apply__3
           [mod_0, ErlangAtom "is_empty", ErlangCons d_27 ErlangEmptyList]
       lambda_2 [(ErlangAtom "iterator"), s_33] =
         BIF.erlang__apply__3
           [mod_0, ErlangAtom "iterator", ErlangCons s_33 ErlangEmptyList]
       lambda_2 [(ErlangAtom "iterator_from"),
                 (ErlangTuple [start_39, s_40])]
         =
         BIF.erlang__apply__3
           [mod_0, ErlangAtom "iterator_from",
            ErlangCons start_39 (ErlangCons s_40 ErlangEmptyList)]
       lambda_2 [(ErlangAtom "next"), i_48] =
         BIF.erlang__apply__3
           [mod_0, ErlangAtom "next", ErlangCons i_48 ErlangEmptyList]
       lambda_2 [(ErlangAtom "to_list"), d_54] =
         erlps__to_list__2 [mod_0, d_54]
       lambda_2 [(ErlangAtom "erase"), (ErlangTuple [k_57, d_58])] =
         erlps__erase__3 [mod_0, k_57, d_58]
       lambda_2 [(ErlangAtom "take"), (ErlangTuple [k_62, d_63])] =
         erlps__take__3 [mod_0, k_62, d_63]
       lambda_2 [arg_3, arg_4] = EXC.function_clause unit
       lambda_2 args = EXC.badarity (ErlangFun 2 lambda_2) args
     in lambda_2)
erlps__new__2 [arg_67, arg_68] = EXC.function_clause unit
erlps__new__2 args =
  EXC.badarity (ErlangFun 2 erlps__new__2) args

erlps__empty__1 :: ErlangFun
erlps__empty__1 [mod_0] =
  let matchExpr_3 = BIF.code__ensure_loaded__1 [mod_0]
  in
    case matchExpr_3 of
      (ErlangTuple [(ErlangAtom "module"), mod_2]) | mod_2 == mod_0 ->
        let    arg_7 = toErl 0
        in let
          case_4 =
            BIF.erlang__function_exported__3 [mod_0, ErlangAtom "new", arg_7]
        in
          case case_4 of
            (ErlangAtom "false") ->
              BIF.erlang__apply__3 [mod_0, ErlangAtom "empty", ErlangEmptyList]
            (ErlangAtom "true") ->
              BIF.erlang__apply__3 [mod_0, ErlangAtom "new", ErlangEmptyList]
            something_else -> EXC.case_clause something_else
      _ -> EXC.badmatch matchExpr_3
erlps__empty__1 [arg_14] = EXC.function_clause unit
erlps__empty__1 args =
  EXC.badarity (ErlangFun 1 erlps__empty__1) args

erlps__to_list__2 :: ErlangFun
erlps__to_list__2 [mod_0, d_1] =
  BIF.erlang__apply__3
    [mod_0, ErlangAtom "to_list", ErlangCons d_1 ErlangEmptyList]
erlps__to_list__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__to_list__2 args =
  EXC.badarity (ErlangFun 2 erlps__to_list__2) args

erlps__from_list__2 :: ErlangFun
erlps__from_list__2 [mod_0, l_1] =
  let matchExpr_4 = BIF.code__ensure_loaded__1 [mod_0]
  in
    case matchExpr_4 of
      (ErlangTuple [(ErlangAtom "module"), mod_3]) | mod_3 == mod_0 ->
        let    arg_8 = toErl 1
        in let
          case_5 =
            BIF.erlang__function_exported__3
              [mod_0, ErlangAtom "from_orddict", arg_8]
        in
          case case_5 of
            (ErlangAtom "false") ->
              BIF.erlang__apply__3
                [mod_0, ErlangAtom "from_list", ErlangCons l_1 ErlangEmptyList]
            (ErlangAtom "true") ->
              let
                orddict_15 =
                  BIF.do_remote_fun_call "Orddict" "erlps__from_list__1" [l_1]
              in
                BIF.erlang__apply__3
                  [mod_0, ErlangAtom "from_orddict",
                   ErlangCons orddict_15 ErlangEmptyList]
            something_else -> EXC.case_clause something_else
      _ -> EXC.badmatch matchExpr_4
erlps__from_list__2 [arg_21, arg_22] = EXC.function_clause unit
erlps__from_list__2 args =
  EXC.badarity (ErlangFun 2 erlps__from_list__2) args

erlps__enter__4 :: ErlangFun
erlps__enter__4 [mod_0, key_1, val_2, dict_3] =
  let matchExpr_6 = BIF.code__ensure_loaded__1 [mod_0]
  in
    case matchExpr_6 of
      (ErlangTuple [(ErlangAtom "module"), mod_5]) | mod_5 == mod_0 ->
        let    arg_10 = toErl 3
        in let
          case_7 =
            BIF.erlang__function_exported__3
              [mod_0, ErlangAtom "store", arg_10]
        in
          case case_7 of
            (ErlangAtom "false") ->
              BIF.erlang__apply__3
                [mod_0, ErlangAtom "enter",
                 ErlangCons key_1
                   (ErlangCons val_2 (ErlangCons dict_3 ErlangEmptyList))]
            (ErlangAtom "true") ->
              BIF.erlang__apply__3
                [mod_0, ErlangAtom "store",
                 ErlangCons key_1
                   (ErlangCons val_2 (ErlangCons dict_3 ErlangEmptyList))]
            something_else -> EXC.case_clause something_else
      _ -> EXC.badmatch matchExpr_6
erlps__enter__4 [arg_29, arg_30, arg_31, arg_32] =
  EXC.function_clause unit
erlps__enter__4 args =
  EXC.badarity (ErlangFun 4 erlps__enter__4) args

erlps__erase__3 :: ErlangFun
erlps__erase__3 [mod_0, key_1, val_2]
  | ((==) mod_0 (ErlangAtom "dict")) ||
      ((==) mod_0 (ErlangAtom "orddict")) =
  BIF.erlang__apply__3
    [mod_0, ErlangAtom "erase",
     ErlangCons key_1 (ErlangCons val_2 ErlangEmptyList)]
erlps__erase__3 [(ErlangAtom "gb_trees"), key_0, val_1] =
  BIF.do_remote_fun_call "Gb.Trees" "erlps__delete_any__2"
    [key_0, val_1]
erlps__erase__3 [arg_4, arg_5, arg_6] = EXC.function_clause unit
erlps__erase__3 args =
  EXC.badarity (ErlangFun 3 erlps__erase__3) args

erlps__take__3 :: ErlangFun
erlps__take__3 [(ErlangAtom "gb_trees"), key_0, val_1] =
  let   
    res_7 =
      EXC.tryCatch
        (\ _ ->
           BIF.do_remote_fun_call "Gb.Trees" "erlps__take__2"
             [key_0, val_1])
        (\ ex_5 ->
           case ex_5 of
             (ErlangTuple [(ErlangAtom "error"), _, _]) -> ErlangAtom "error"
             ex_6 -> EXC.raise ex_6)
  in let
    match_final_8_11 =
      BIF.do_remote_fun_call "Gb.Trees" "erlps__take_any__2"
        [key_0, val_1]
  in
    case match_final_8_11 of
      res_12 | res_12 == res_7 -> match_final_8_11
      _ -> EXC.badmatch match_final_8_11
erlps__take__3 [mod_0, key_1, val_2] =
  BIF.erlang__apply__3
    [mod_0, ErlangAtom "take",
     ErlangCons key_1 (ErlangCons val_2 ErlangEmptyList)]
erlps__take__3 [arg_10, arg_11, arg_12] =
  EXC.function_clause unit
erlps__take__3 args =
  EXC.badarity (ErlangFun 3 erlps__take__3) args