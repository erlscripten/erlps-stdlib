module Maps(erlps__get__3, erlps__filter__2, erlps__filtermap__2,
            erlps__fold__3, erlps__foreach__2, erlps__map__2, erlps__size__1,
            erlps__new__0, erlps__update_with__3, erlps__update_with__4,
            erlps__without__2, erlps__with__2, erlps__iterator__1,
            erlps__next__1, erlps__intersect__2, erlps__intersect_with__3,
            erlps__merge_with__3, erlps__groups_from_list__2,
            erlps__groups_from_list__3, erlps__get__2, erlps__find__2,
            erlps__from_list__1, erlps__from_keys__2, erlps__is_key__2,
            erlps__keys__1, erlps__merge__2, erlps__put__3, erlps__remove__2,
            erlps__take__2, erlps__to_list__1, erlps__update__3,
            erlps__values__1) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__get__2 :: ErlangFun
erlps__get__2 [_, _] =
  BIF.erlang__nif_error__1 [ErlangAtom "undef"]
erlps__get__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__get__2 args =
  EXC.badarity (ErlangFun 2 erlps__get__2) args

erlps__find__2 :: ErlangFun
erlps__find__2 [_, _] =
  BIF.erlang__nif_error__1 [ErlangAtom "undef"]
erlps__find__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__find__2 args =
  EXC.badarity (ErlangFun 2 erlps__find__2) args

erlps__from_list__1 :: ErlangFun
erlps__from_list__1 [_] =
  BIF.erlang__nif_error__1 [ErlangAtom "undef"]
erlps__from_list__1 [arg_1] = EXC.function_clause unit
erlps__from_list__1 args =
  EXC.badarity (ErlangFun 1 erlps__from_list__1) args

erlps__from_keys__2 :: ErlangFun
erlps__from_keys__2 [_, _] =
  BIF.erlang__nif_error__1 [ErlangAtom "undef"]
erlps__from_keys__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__from_keys__2 args =
  EXC.badarity (ErlangFun 2 erlps__from_keys__2) args

erlps__intersect__2 :: ErlangFun
erlps__intersect__2 [map1_0, map2_1]
  | (isEMap map1_0) && (isEMap map2_1) =
  let    lop_3 = BIF.erlang__map_size__1 [map1_0]
  in let rop_5 = BIF.erlang__map_size__1 [map2_1]
  in let case_2 = BIF.erlang__op_lesserEq [lop_3, rop_5]
  in
    case case_2 of
      (ErlangAtom "true") ->
        let arg_7 = ErlangFun 3 erlps__intersect_combiner_v2__3
        in
          erlps__intersect_with_small_map_first__3 [arg_7, map1_0, map2_1]
      (ErlangAtom "false") ->
        let arg_10 = ErlangFun 3 erlps__intersect_combiner_v1__3
        in
          erlps__intersect_with_small_map_first__3 [arg_10, map2_1, map1_0]
      something_else -> EXC.case_clause something_else
erlps__intersect__2 [map1_0, map2_1] =
  let arg_2 = erlps__error_type_two_maps__2 [map1_0, map2_1]
  in
    erlps__error_with_info__2
      [arg_2, ErlangCons map1_0 (ErlangCons map2_1 ErlangEmptyList)]
erlps__intersect__2 [arg_10, arg_11] = EXC.function_clause unit
erlps__intersect__2 args =
  EXC.badarity (ErlangFun 2 erlps__intersect__2) args

erlps__intersect_combiner_v1__3 :: ErlangFun
erlps__intersect_combiner_v1__3 [_k_0, v1_1, _v2_2] = v1_1
erlps__intersect_combiner_v1__3 [arg_3, arg_4, arg_5] =
  EXC.function_clause unit
erlps__intersect_combiner_v1__3 args =
  EXC.badarity (ErlangFun 3 erlps__intersect_combiner_v1__3) args

erlps__intersect_combiner_v2__3 :: ErlangFun
erlps__intersect_combiner_v2__3 [_k_0, _v1_1, v2_2] = v2_2
erlps__intersect_combiner_v2__3 [arg_3, arg_4, arg_5] =
  EXC.function_clause unit
erlps__intersect_combiner_v2__3 args =
  EXC.badarity (ErlangFun 3 erlps__intersect_combiner_v2__3) args

erlps__intersect_with__3 :: ErlangFun
erlps__intersect_with__3 [combiner_0, map1_1, map2_2]
  | ((isEMap map1_1) && (isEMap map2_2)) &&
      (isEFunA combiner_0 (toErl 3)) =
  let    lop_4 = BIF.erlang__map_size__1 [map1_1]
  in let rop_6 = BIF.erlang__map_size__1 [map2_2]
  in let case_3 = BIF.erlang__op_lesserEq [lop_4, rop_6]
  in
    case case_3 of
      (ErlangAtom "true") ->
        erlps__intersect_with_small_map_first__3
          [combiner_0, map1_1, map2_2]
      (ErlangAtom "false") ->
        let
          rcombiner_22 =
            ErlangFun 3
              (let
                 lambda_11 [k_15, v1_16, v2_17] =
                   BIF.erlang__apply__2
                     [combiner_0,
                      ErlangCons k_15
                        (ErlangCons v2_17 (ErlangCons v1_16 ErlangEmptyList))]
                 lambda_11 [arg_12, arg_13, arg_14] = EXC.function_clause unit
                 lambda_11 args = EXC.badarity (ErlangFun 3 lambda_11) args
               in lambda_11)
        in
          erlps__intersect_with_small_map_first__3
            [rcombiner_22, map2_2, map1_1]
      something_else -> EXC.case_clause something_else
erlps__intersect_with__3 [combiner_0, map1_1, map2_2] =
  let
    arg_3 =
      erlps__error_type_merge_intersect__3 [map1_1, map2_2, combiner_0]
  in
    erlps__error_with_info__2
      [arg_3,
       ErlangCons combiner_0
         (ErlangCons map1_1 (ErlangCons map2_2 ErlangEmptyList))]
erlps__intersect_with__3 [arg_14, arg_15, arg_16] =
  EXC.function_clause unit
erlps__intersect_with__3 args =
  EXC.badarity (ErlangFun 3 erlps__intersect_with__3) args

erlps__intersect_with_small_map_first__3 :: ErlangFun
erlps__intersect_with_small_map_first__3 [combiner_0, smallmap_1,
                                          bigmap_2]
  =
  let    arg_3 = erlps__iterator__1 [smallmap_1]
  in let next_5 = erlps__next__1 [arg_3]
  in
    erlps__intersect_with_iterate__4
      [next_5, ErlangEmptyList, bigmap_2, combiner_0]
erlps__intersect_with_small_map_first__3 [arg_10, arg_11, arg_12]
  =
  EXC.function_clause unit
erlps__intersect_with_small_map_first__3 args =
  EXC.badarity
    (ErlangFun 3 erlps__intersect_with_small_map_first__3) args

erlps__intersect_with_iterate__4 :: ErlangFun
erlps__intersect_with_iterate__4 [(ErlangTuple [k_0, v1_1,
                                                iterator_2]),
                                  keep_3, bigmap_4, combiner_5]
  =
  let next_7 = erlps__next__1 [iterator_2]
  in
    case bigmap_4 of
      (ErlangMap map_9) | (DM.Just v2_10) <- (Map.lookup k_0 map_9) ->
        let   
          v_15 =
            BIF.erlang__apply__2
              [combiner_5,
               ErlangCons k_0
                 (ErlangCons v1_1 (ErlangCons v2_10 ErlangEmptyList))]
        in let head_18 = ErlangTuple [k_0, v_15]
        in
          erlps__intersect_with_iterate__4
            [next_7, ErlangCons head_18 keep_3, bigmap_4, combiner_5]
      _ ->
        erlps__intersect_with_iterate__4
          [next_7, keep_3, bigmap_4, combiner_5]
erlps__intersect_with_iterate__4 [(ErlangAtom "none"), keep_0,
                                  _bigmap2_1, _combiner_2]
  =
  BIF.maps__from_list__1 [keep_0]
erlps__intersect_with_iterate__4 [arg_4, arg_5, arg_6, arg_7] =
  EXC.function_clause unit
erlps__intersect_with_iterate__4 args =
  EXC.badarity (ErlangFun 4 erlps__intersect_with_iterate__4) args

erlps__is_key__2 :: ErlangFun
erlps__is_key__2 [_, _] =
  BIF.erlang__nif_error__1 [ErlangAtom "undef"]
erlps__is_key__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__is_key__2 args =
  EXC.badarity (ErlangFun 2 erlps__is_key__2) args

erlps__keys__1 :: ErlangFun
erlps__keys__1 [_] =
  BIF.erlang__nif_error__1 [ErlangAtom "undef"]
erlps__keys__1 [arg_1] = EXC.function_clause unit
erlps__keys__1 args =
  EXC.badarity (ErlangFun 1 erlps__keys__1) args

erlps__merge__2 :: ErlangFun
erlps__merge__2 [_, _] =
  BIF.erlang__nif_error__1 [ErlangAtom "undef"]
erlps__merge__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__merge__2 args =
  EXC.badarity (ErlangFun 2 erlps__merge__2) args

erlps__merge_with__3 :: ErlangFun
erlps__merge_with__3 [combiner_0, map1_1, map2_2]
  | ((isEMap map1_1) && (isEMap map2_2)) &&
      (isEFunA combiner_0 (toErl 3)) =
  let    lop_4 = BIF.erlang__map_size__1 [map1_1]
  in let rop_6 = BIF.erlang__map_size__1 [map2_2]
  in let case_3 = BIF.erlang__op_greater [lop_4, rop_6]
  in
    case case_3 of
      (ErlangAtom "true") ->
        let    iterator_9 = erlps__iterator__1 [map2_2]
        in let arg_10 = erlps__next__1 [iterator_9]
        in erlps__merge_with_1__4 [arg_10, map1_1, map2_2, combiner_0]
      (ErlangAtom "false") ->
        let    iterator_16 = erlps__iterator__1 [map1_1]
        in let arg_17 = erlps__next__1 [iterator_16]
        in let
          arg_21 =
            ErlangFun 3
              (let
                 lambda_22 [k_26, v1_27, v2_28] =
                   BIF.erlang__apply__2
                     [combiner_0,
                      ErlangCons k_26
                        (ErlangCons v2_28 (ErlangCons v1_27 ErlangEmptyList))]
                 lambda_22 [arg_23, arg_24, arg_25] = EXC.function_clause unit
                 lambda_22 args = EXC.badarity (ErlangFun 3 lambda_22) args
               in lambda_22)
        in erlps__merge_with_1__4 [arg_17, map2_2, map1_1, arg_21]
      something_else -> EXC.case_clause something_else
erlps__merge_with__3 [combiner_0, map1_1, map2_2] =
  let
    arg_3 =
      erlps__error_type_merge_intersect__3 [map1_1, map2_2, combiner_0]
  in
    erlps__error_with_info__2
      [arg_3,
       ErlangCons combiner_0
         (ErlangCons map1_1 (ErlangCons map2_2 ErlangEmptyList))]
erlps__merge_with__3 [arg_14, arg_15, arg_16] =
  EXC.function_clause unit
erlps__merge_with__3 args =
  EXC.badarity (ErlangFun 3 erlps__merge_with__3) args

erlps__merge_with_1__4 :: ErlangFun
erlps__merge_with_1__4 [(ErlangTuple [k_0, v2_1, iterator_2]),
                        map1_3, map2_4, combiner_5]
  =
  case map1_3 of
    (ErlangMap map_7) | (DM.Just v1_8) <- (Map.lookup k_0 map_7) ->
      let   
        val_11 =
          BIF.erlang__apply__2
            [combiner_5,
             ErlangCons k_0
               (ErlangCons v1_8 (ErlangCons v2_1 ErlangEmptyList))]
      in let mapExt_16 = ErlangMap (Map.singleton k_0 val_11)
      in let
        newmap1_19 =
          case findMissingKey map1_3 [k_0] of
            (DM.Nothing) -> BIF.maps__merge__2 [map1_3, mapExt_16]
            (DM.Just missing_18) -> EXC.badkey missing_18
      in let arg_20 = erlps__next__1 [iterator_2]
      in
        erlps__merge_with_1__4 [arg_20, newmap1_19, map2_4, combiner_5]
    (ErlangMap map_25) ->
      let    arg_26 = erlps__next__1 [iterator_2]
      in let arg_28 = BIF.maps__put__3 [k_0, v2_1, map1_3]
      in erlps__merge_with_1__4 [arg_26, arg_28, map2_4, combiner_5]
    something_else -> EXC.case_clause something_else
erlps__merge_with_1__4 [(ErlangAtom "none"), result_0, _, _] =
  result_0
erlps__merge_with_1__4 [arg_1, arg_2, arg_3, arg_4] =
  EXC.function_clause unit
erlps__merge_with_1__4 args =
  EXC.badarity (ErlangFun 4 erlps__merge_with_1__4) args

erlps__put__3 :: ErlangFun
erlps__put__3 [_, _, _] =
  BIF.erlang__nif_error__1 [ErlangAtom "undef"]
erlps__put__3 [arg_1, arg_2, arg_3] = EXC.function_clause unit
erlps__put__3 args =
  EXC.badarity (ErlangFun 3 erlps__put__3) args

erlps__remove__2 :: ErlangFun
erlps__remove__2 [_, _] =
  BIF.erlang__nif_error__1 [ErlangAtom "undef"]
erlps__remove__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__remove__2 args =
  EXC.badarity (ErlangFun 2 erlps__remove__2) args

erlps__take__2 :: ErlangFun
erlps__take__2 [_, _] =
  BIF.erlang__nif_error__1 [ErlangAtom "undef"]
erlps__take__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__take__2 args =
  EXC.badarity (ErlangFun 2 erlps__take__2) args

erlps__to_list__1 :: ErlangFun
erlps__to_list__1 [map_0] | isEMap map_0 =
  let    arg_2 = toErl 0
  in let
    arg_1 =
      BIF.erts_internal__map_next__3 [arg_2, map_0, ErlangEmptyList]
  in erlps__to_list_internal__1 [arg_1]
erlps__to_list__1 [map_0] =
  let arg_1 = ErlangTuple [ErlangAtom "badmap", map_0]
  in
    erlps__error_with_info__2
      [arg_1, ErlangCons map_0 ErlangEmptyList]
erlps__to_list__1 [arg_7] = EXC.function_clause unit
erlps__to_list__1 args =
  EXC.badarity (ErlangFun 1 erlps__to_list__1) args

erlps__to_list_internal__1 :: ErlangFun
erlps__to_list_internal__1 [(ErlangCons iter_0 (ErlangCons map_1 acc_2))]
  | isEInt iter_0 =
  let arg_3 = BIF.erts_internal__map_next__3 [iter_0, map_1, acc_2]
  in erlps__to_list_internal__1 [arg_3]
erlps__to_list_internal__1 [acc_0] = acc_0
erlps__to_list_internal__1 [arg_1] = EXC.function_clause unit
erlps__to_list_internal__1 args =
  EXC.badarity (ErlangFun 1 erlps__to_list_internal__1) args

erlps__update__3 :: ErlangFun
erlps__update__3 [_, _, _] =
  BIF.erlang__nif_error__1 [ErlangAtom "undef"]
erlps__update__3 [arg_1, arg_2, arg_3] = EXC.function_clause unit
erlps__update__3 args =
  EXC.badarity (ErlangFun 3 erlps__update__3) args

erlps__values__1 :: ErlangFun
erlps__values__1 [_] =
  BIF.erlang__nif_error__1 [ErlangAtom "undef"]
erlps__values__1 [arg_1] = EXC.function_clause unit
erlps__values__1 args =
  EXC.badarity (ErlangFun 1 erlps__values__1) args

erlps__new__0 :: ErlangFun
erlps__new__0 [] = ErlangMap Map.empty
erlps__new__0 args =
  EXC.badarity (ErlangFun 0 erlps__new__0) args

erlps__update_with__3 :: ErlangFun
erlps__update_with__3 [key_0, fun_1, map_2]
  | (isEFunA fun_1 (toErl 1)) && (isEMap map_2) =
  case map_2 of
    (ErlangMap map_4) | (DM.Just value_5) <-
                          (Map.lookup key_0 map_4) ->
      let   
        val_8 =
          BIF.erlang__apply__2 [fun_1, ErlangCons value_5 ErlangEmptyList]
      in let mapExt_11 = ErlangMap (Map.singleton key_0 val_8)
      in
        case findMissingKey map_2 [key_0] of
          (DM.Nothing) -> BIF.maps__merge__2 [map_2, mapExt_11]
          (DM.Just missing_13) -> EXC.badkey missing_13
    (ErlangMap map_14) ->
      let arg_15 = ErlangTuple [ErlangAtom "badkey", key_0]
      in
        BIF.erlang__error__2
          [arg_15,
           ErlangCons key_0
             (ErlangCons fun_1 (ErlangCons map_2 ErlangEmptyList))]
    something_else -> EXC.case_clause something_else
erlps__update_with__3 [key_0, fun_1, map_2] =
  let arg_3 = erlps__error_type__1 [map_2]
  in
    erlps__error_with_info__2
      [arg_3,
       ErlangCons key_0
         (ErlangCons fun_1 (ErlangCons map_2 ErlangEmptyList))]
erlps__update_with__3 [arg_12, arg_13, arg_14] =
  EXC.function_clause unit
erlps__update_with__3 args =
  EXC.badarity (ErlangFun 3 erlps__update_with__3) args

erlps__update_with__4 :: ErlangFun
erlps__update_with__4 [key_0, fun_1, init_2, map_3]
  | (isEFunA fun_1 (toErl 1)) && (isEMap map_3) =
  case map_3 of
    (ErlangMap map_5) | (DM.Just value_6) <-
                          (Map.lookup key_0 map_5) ->
      let   
        val_9 =
          BIF.erlang__apply__2 [fun_1, ErlangCons value_6 ErlangEmptyList]
      in let mapExt_12 = ErlangMap (Map.singleton key_0 val_9)
      in
        case findMissingKey map_3 [key_0] of
          (DM.Nothing) -> BIF.maps__merge__2 [map_3, mapExt_12]
          (DM.Just missing_14) -> EXC.badkey missing_14
    (ErlangMap map_15) ->
      let mapExt_19 = ErlangMap (Map.singleton key_0 init_2)
      in BIF.maps__merge__2 [map_3, mapExt_19]
    something_else -> EXC.case_clause something_else
erlps__update_with__4 [key_0, fun_1, init_2, map_3] =
  let arg_4 = erlps__error_type__1 [map_3]
  in
    erlps__error_with_info__2
      [arg_4,
       ErlangCons key_0
         (ErlangCons fun_1
            (ErlangCons init_2 (ErlangCons map_3 ErlangEmptyList)))]
erlps__update_with__4 [arg_15, arg_16, arg_17, arg_18] =
  EXC.function_clause unit
erlps__update_with__4 args =
  EXC.badarity (ErlangFun 4 erlps__update_with__4) args

erlps__get__3 :: ErlangFun
erlps__get__3 [key_0, map_1, default_2] | isEMap map_1 =
  case map_1 of
    (ErlangMap map_4) | (DM.Just value_5) <-
                          (Map.lookup key_0 map_4) ->
      value_5
    (ErlangMap map_6) -> default_2
    something_else -> EXC.case_clause something_else
erlps__get__3 [key_0, map_1, default_2] =
  let arg_3 = ErlangTuple [ErlangAtom "badmap", map_1]
  in
    erlps__error_with_info__2
      [arg_3,
       ErlangCons key_0
         (ErlangCons map_1 (ErlangCons default_2 ErlangEmptyList))]
erlps__get__3 [arg_13, arg_14, arg_15] = EXC.function_clause unit
erlps__get__3 args =
  EXC.badarity (ErlangFun 3 erlps__get__3) args

erlps__filter__2 :: ErlangFun
erlps__filter__2 [pred_0, maporiter_1]
  | isEFunA pred_0 (toErl 2) =
  let
    iter_3 =
      case ErlangAtom "true" of
        _ | isEMap maporiter_1 -> erlps__iterator__1 [maporiter_1]
        _ -> maporiter_1
  in
    EXC.tryOfCatch (\ _ -> erlps__next__1 [iter_3])
      (\ of_5 ->
         let arg_9 = erlps__filter_1__2 [pred_0, of_5]
         in BIF.maps__from_list__1 [arg_9])
      (\ ex_6 ->
         case ex_6 of
           (ErlangTuple [(ErlangAtom "error"), _, _]) ->
             let arg_12 = ErlangTuple [ErlangAtom "badmap", maporiter_1]
             in
               erlps__error_with_info__2
                 [arg_12,
                  ErlangCons pred_0 (ErlangCons maporiter_1 ErlangEmptyList)]
           ex_7 -> EXC.raise ex_7)
erlps__filter__2 [pred_0, map_1] =
  erlps__badarg_with_info__1
    [ErlangCons pred_0 (ErlangCons map_1 ErlangEmptyList)]
erlps__filter__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__filter__2 args =
  EXC.badarity (ErlangFun 2 erlps__filter__2) args

erlps__filter_1__2 :: ErlangFun
erlps__filter_1__2 [pred_0, (ErlangTuple [k_1, v_2, iter_3])] =
  let
    case_4 =
      BIF.erlang__apply__2
        [pred_0, ErlangCons k_1 (ErlangCons v_2 ErlangEmptyList)]
  in
    case case_4 of
      (ErlangAtom "true") ->
        let    head_8 = ErlangTuple [k_1, v_2]
        in let arg_13 = erlps__next__1 [iter_3]
        in let tail_11 = erlps__filter_1__2 [pred_0, arg_13]
        in ErlangCons head_8 tail_11
      (ErlangAtom "false") ->
        let arg_16 = erlps__next__1 [iter_3]
        in erlps__filter_1__2 [pred_0, arg_16]
      something_else -> EXC.case_clause something_else
erlps__filter_1__2 [_pred_0, (ErlangAtom "none")] =
  ErlangEmptyList
erlps__filter_1__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__filter_1__2 args =
  EXC.badarity (ErlangFun 2 erlps__filter_1__2) args

erlps__filtermap__2 :: ErlangFun
erlps__filtermap__2 [fun_0, maporiter_1]
  | isEFunA fun_0 (toErl 2) =
  let
    iter_3 =
      case ErlangAtom "true" of
        _ | isEMap maporiter_1 -> erlps__iterator__1 [maporiter_1]
        _ -> maporiter_1
  in
    EXC.tryOfCatch (\ _ -> erlps__next__1 [iter_3])
      (\ of_5 ->
         let arg_9 = erlps__filtermap_1__2 [fun_0, of_5]
         in BIF.maps__from_list__1 [arg_9])
      (\ ex_6 ->
         case ex_6 of
           (ErlangTuple [(ErlangAtom "error"), _, _]) ->
             let arg_12 = ErlangTuple [ErlangAtom "badmap", maporiter_1]
             in
               erlps__error_with_info__2
                 [arg_12,
                  ErlangCons fun_0 (ErlangCons maporiter_1 ErlangEmptyList)]
           ex_7 -> EXC.raise ex_7)
erlps__filtermap__2 [fun_0, map_1] =
  erlps__badarg_with_info__1
    [ErlangCons fun_0 (ErlangCons map_1 ErlangEmptyList)]
erlps__filtermap__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__filtermap__2 args =
  EXC.badarity (ErlangFun 2 erlps__filtermap__2) args

erlps__filtermap_1__2 :: ErlangFun
erlps__filtermap_1__2 [pred_0, (ErlangTuple [k_1, v_2, iter_3])]
  =
  let
    case_4 =
      BIF.erlang__apply__2
        [pred_0, ErlangCons k_1 (ErlangCons v_2 ErlangEmptyList)]
  in
    case case_4 of
      (ErlangAtom "true") ->
        let    head_8 = ErlangTuple [k_1, v_2]
        in let arg_13 = erlps__next__1 [iter_3]
        in let tail_11 = erlps__filtermap_1__2 [pred_0, arg_13]
        in ErlangCons head_8 tail_11
      (ErlangTuple [(ErlangAtom "true"), newv_15]) ->
        let    head_16 = ErlangTuple [k_1, newv_15]
        in let arg_21 = erlps__next__1 [iter_3]
        in let tail_19 = erlps__filtermap_1__2 [pred_0, arg_21]
        in ErlangCons head_16 tail_19
      (ErlangAtom "false") ->
        let arg_24 = erlps__next__1 [iter_3]
        in erlps__filtermap_1__2 [pred_0, arg_24]
      something_else -> EXC.case_clause something_else
erlps__filtermap_1__2 [_pred_0, (ErlangAtom "none")] =
  ErlangEmptyList
erlps__filtermap_1__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__filtermap_1__2 args =
  EXC.badarity (ErlangFun 2 erlps__filtermap_1__2) args

erlps__foreach__2 :: ErlangFun
erlps__foreach__2 [fun_0, maporiter_1]
  | isEFunA fun_0 (toErl 2) =
  let
    iter_3 =
      case ErlangAtom "true" of
        _ | isEMap maporiter_1 -> erlps__iterator__1 [maporiter_1]
        _ -> maporiter_1
  in
    EXC.tryOfCatch (\ _ -> erlps__next__1 [iter_3])
      (\ of_5 -> erlps__foreach_1__2 [fun_0, of_5])
      (\ ex_6 ->
         case ex_6 of
           (ErlangTuple [(ErlangAtom "error"), _, _]) ->
             let arg_11 = ErlangTuple [ErlangAtom "badmap", maporiter_1]
             in
               erlps__error_with_info__2
                 [arg_11,
                  ErlangCons fun_0 (ErlangCons maporiter_1 ErlangEmptyList)]
           ex_7 -> EXC.raise ex_7)
erlps__foreach__2 [pred_0, map_1] =
  erlps__badarg_with_info__1
    [ErlangCons pred_0 (ErlangCons map_1 ErlangEmptyList)]
erlps__foreach__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__foreach__2 args =
  EXC.badarity (ErlangFun 2 erlps__foreach__2) args

erlps__foreach_1__2 :: ErlangFun
erlps__foreach_1__2 [fun_0, (ErlangTuple [k_1, v_2, iter_3])] =
  let   
    _ =
      BIF.erlang__apply__2
        [fun_0, ErlangCons k_1 (ErlangCons v_2 ErlangEmptyList)]
  in let arg_8 = erlps__next__1 [iter_3]
  in erlps__foreach_1__2 [fun_0, arg_8]
erlps__foreach_1__2 [_fun_0, (ErlangAtom "none")] =
  ErlangAtom "ok"
erlps__foreach_1__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__foreach_1__2 args =
  EXC.badarity (ErlangFun 2 erlps__foreach_1__2) args

erlps__fold__3 :: ErlangFun
erlps__fold__3 [fun_0, init_1, maporiter_2]
  | isEFunA fun_0 (toErl 3) =
  let
    iter_4 =
      case ErlangAtom "true" of
        _ | isEMap maporiter_2 -> erlps__iterator__1 [maporiter_2]
        _ -> maporiter_2
  in
    EXC.tryOfCatch (\ _ -> erlps__next__1 [iter_4])
      (\ of_6 -> erlps__fold_1__3 [fun_0, init_1, of_6])
      (\ ex_7 ->
         case ex_7 of
           (ErlangTuple [(ErlangAtom "error"), _, _]) ->
             let arg_13 = ErlangTuple [ErlangAtom "badmap", maporiter_2]
             in
               erlps__error_with_info__2
                 [arg_13,
                  ErlangCons fun_0
                    (ErlangCons init_1
                       (ErlangCons maporiter_2 ErlangEmptyList))]
           ex_8 -> EXC.raise ex_8)
erlps__fold__3 [fun_0, init_1, map_2] =
  erlps__badarg_with_info__1
    [ErlangCons fun_0
       (ErlangCons init_1 (ErlangCons map_2 ErlangEmptyList))]
erlps__fold__3 [arg_10, arg_11, arg_12] =
  EXC.function_clause unit
erlps__fold__3 args =
  EXC.badarity (ErlangFun 3 erlps__fold__3) args

erlps__fold_1__3 :: ErlangFun
erlps__fold_1__3 [fun_0, acc_1, (ErlangTuple [k_2, v_3, iter_4])]
  =
  let   
    arg_6 =
      BIF.erlang__apply__2
        [fun_0,
         ErlangCons k_2
           (ErlangCons v_3 (ErlangCons acc_1 ErlangEmptyList))]
  in let arg_11 = erlps__next__1 [iter_4]
  in erlps__fold_1__3 [fun_0, arg_6, arg_11]
erlps__fold_1__3 [_fun_0, acc_1, (ErlangAtom "none")] = acc_1
erlps__fold_1__3 [arg_2, arg_3, arg_4] = EXC.function_clause unit
erlps__fold_1__3 args =
  EXC.badarity (ErlangFun 3 erlps__fold_1__3) args

erlps__map__2 :: ErlangFun
erlps__map__2 [fun_0, maporiter_1] | isEFunA fun_0 (toErl 2) =
  let
    iter_3 =
      case ErlangAtom "true" of
        _ | isEMap maporiter_1 -> erlps__iterator__1 [maporiter_1]
        _ -> maporiter_1
  in
    EXC.tryOfCatch (\ _ -> erlps__next__1 [iter_3])
      (\ of_5 ->
         let arg_9 = erlps__map_1__2 [fun_0, of_5]
         in BIF.maps__from_list__1 [arg_9])
      (\ ex_6 ->
         case ex_6 of
           (ErlangTuple [(ErlangAtom "error"), _, _]) ->
             let arg_12 = ErlangTuple [ErlangAtom "badmap", maporiter_1]
             in
               erlps__error_with_info__2
                 [arg_12,
                  ErlangCons fun_0 (ErlangCons maporiter_1 ErlangEmptyList)]
           ex_7 -> EXC.raise ex_7)
erlps__map__2 [fun_0, map_1] =
  erlps__badarg_with_info__1
    [ErlangCons fun_0 (ErlangCons map_1 ErlangEmptyList)]
erlps__map__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__map__2 args =
  EXC.badarity (ErlangFun 2 erlps__map__2) args

erlps__map_1__2 :: ErlangFun
erlps__map_1__2 [fun_0, (ErlangTuple [k_1, v_2, iter_3])] =
  let   
    tup_el_6 =
      BIF.erlang__apply__2
        [fun_0, ErlangCons k_1 (ErlangCons v_2 ErlangEmptyList)]
  in let head_4 = ErlangTuple [k_1, tup_el_6]
  in let arg_12 = erlps__next__1 [iter_3]
  in let tail_10 = erlps__map_1__2 [fun_0, arg_12]
  in ErlangCons head_4 tail_10
erlps__map_1__2 [_fun_0, (ErlangAtom "none")] = ErlangEmptyList
erlps__map_1__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__map_1__2 args =
  EXC.badarity (ErlangFun 2 erlps__map_1__2) args

erlps__size__1 :: ErlangFun
erlps__size__1 [map_0] =
  EXC.tryCatch (\ _ -> BIF.erlang__map_size__1 [map_0])
    (\ ex_3 ->
       case ex_3 of
         (ErlangTuple [_, _, _]) ->
           let arg_5 = ErlangTuple [ErlangAtom "badmap", map_0]
           in
             erlps__error_with_info__2
               [arg_5, ErlangCons map_0 ErlangEmptyList]
         ex_4 -> EXC.raise ex_4)
erlps__size__1 [arg_11] = EXC.function_clause unit
erlps__size__1 args =
  EXC.badarity (ErlangFun 1 erlps__size__1) args

erlps__iterator__1 :: ErlangFun
erlps__iterator__1 [m_0] | isEMap m_0 =
  let head_1 = toErl 0
  in ErlangCons head_1 m_0
erlps__iterator__1 [m_0] =
  let arg_1 = ErlangTuple [ErlangAtom "badmap", m_0]
  in
    erlps__error_with_info__2 [arg_1, ErlangCons m_0 ErlangEmptyList]
erlps__iterator__1 [arg_7] = EXC.function_clause unit
erlps__iterator__1 args =
  EXC.badarity (ErlangFun 1 erlps__iterator__1) args

erlps__next__1 :: ErlangFun
erlps__next__1 [(ErlangTuple [k_0, v_1, i_2])] =
  ErlangTuple [k_0, v_1, i_2]
erlps__next__1 [(ErlangCons path_0 map_1)]
  | (isEInt path_0) && (isEMap map_1) =
  BIF.erts_internal__map_next__3
    [path_0, map_1, ErlangAtom "iterator"]
erlps__next__1 [(ErlangAtom "none")] = ErlangAtom "none"
erlps__next__1 [iter_0] =
  erlps__badarg_with_info__1 [ErlangCons iter_0 ErlangEmptyList]
erlps__next__1 [arg_4] = EXC.function_clause unit
erlps__next__1 args =
  EXC.badarity (ErlangFun 1 erlps__next__1) args

erlps__without__2 :: ErlangFun
erlps__without__2 [ks_0, m_1] | (isEList ks_0) && (isEMap m_1) =
  let    arg_5 = toErl 2
  in let
    arg_2 =
      BIF.erlang__make_fun__3
        [ErlangAtom "maps", ErlangAtom "remove", arg_5]
  in
    BIF.do_remote_fun_call "Lists" "erlps__foldl__3"
      [arg_2, m_1, ks_0]
erlps__without__2 [ks_0, m_1] =
  let arg_2 = erlps__error_type__1 [m_1]
  in
    erlps__error_with_info__2
      [arg_2, ErlangCons ks_0 (ErlangCons m_1 ErlangEmptyList)]
erlps__without__2 [arg_9, arg_10] = EXC.function_clause unit
erlps__without__2 args =
  EXC.badarity (ErlangFun 2 erlps__without__2) args

erlps__with__2 :: ErlangFun
erlps__with__2 [ks_0, map1_1]
  | (isEList ks_0) && (isEMap map1_1) =
  let arg_2 = erlps__with_1__2 [ks_0, map1_1]
  in BIF.maps__from_list__1 [arg_2]
erlps__with__2 [ks_0, m_1] =
  let arg_2 = erlps__error_type__1 [m_1]
  in
    erlps__error_with_info__2
      [arg_2, ErlangCons ks_0 (ErlangCons m_1 ErlangEmptyList)]
erlps__with__2 [arg_9, arg_10] = EXC.function_clause unit
erlps__with__2 args =
  EXC.badarity (ErlangFun 2 erlps__with__2) args

erlps__with_1__2 :: ErlangFun
erlps__with_1__2 [(ErlangCons k_0 ks_1), map_2] =
  case map_2 of
    (ErlangMap map_4) | (DM.Just v_5) <- (Map.lookup k_0 map_4) ->
      let    head_6 = ErlangTuple [k_0, v_5]
      in let tail_9 = erlps__with_1__2 [ks_1, map_2]
      in ErlangCons head_6 tail_9
    (ErlangMap map_12) -> erlps__with_1__2 [ks_1, map_2]
    something_else -> EXC.case_clause something_else
erlps__with_1__2 [(ErlangEmptyList), _map_0] = ErlangEmptyList
erlps__with_1__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__with_1__2 args =
  EXC.badarity (ErlangFun 2 erlps__with_1__2) args

erlps__groups_from_list__2 :: ErlangFun
erlps__groups_from_list__2 [fun_0, list0_1]
  | isEFunA fun_0 (toErl 1) =
  EXC.tryOfCatch
    (\ _ ->
       BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [list0_1])
    (\ of_3 ->
       let arg_9 = ErlangMap Map.empty
       in erlps__groups_from_list_1__3 [fun_0, of_3, arg_9])
    (\ ex_4 ->
       case ex_4 of
         (ErlangTuple [(ErlangAtom "error"), _, _]) ->
           erlps__badarg_with_info__1
             [ErlangCons fun_0 (ErlangCons list0_1 ErlangEmptyList)]
         ex_5 -> EXC.raise ex_5)
erlps__groups_from_list__2 [fun_0, list_1] =
  erlps__badarg_with_info__1
    [ErlangCons fun_0 (ErlangCons list_1 ErlangEmptyList)]
erlps__groups_from_list__2 [arg_7, arg_8] =
  EXC.function_clause unit
erlps__groups_from_list__2 args =
  EXC.badarity (ErlangFun 2 erlps__groups_from_list__2) args

erlps__groups_from_list_1__3 :: ErlangFun
erlps__groups_from_list_1__3 [fun_0, (ErlangCons h_1 tail_2),
                              acc_3]
  =
  let   
    k_6 =
      BIF.erlang__apply__2 [fun_0, ErlangCons h_1 ErlangEmptyList]
  in let
    newacc_26 =
      case acc_3 of
        (ErlangMap map_8) | (DM.Just vs_9) <- (Map.lookup k_6 map_8) ->
          let
            mapExt_15 = ErlangMap (Map.singleton k_6 (ErlangCons h_1 vs_9))
          in
            case findMissingKey acc_3 [k_6] of
              (DM.Nothing) -> BIF.maps__merge__2 [acc_3, mapExt_15]
              (DM.Just missing_17) -> EXC.badkey missing_17
        (ErlangMap map_18) ->
          let
            mapExt_24 =
              ErlangMap (Map.singleton k_6 (ErlangCons h_1 ErlangEmptyList))
          in BIF.maps__merge__2 [acc_3, mapExt_24]
        something_else -> EXC.case_clause something_else
  in erlps__groups_from_list_1__3 [fun_0, tail_2, newacc_26]
erlps__groups_from_list_1__3 [_fun_0, (ErlangEmptyList), acc_1] =
  acc_1
erlps__groups_from_list_1__3 [arg_2, arg_3, arg_4] =
  EXC.function_clause unit
erlps__groups_from_list_1__3 args =
  EXC.badarity (ErlangFun 3 erlps__groups_from_list_1__3) args

erlps__groups_from_list__3 :: ErlangFun
erlps__groups_from_list__3 [fun_0, valuefun_1, list0_2]
  | (isEFunA fun_0 (toErl 1)) && (isEFunA valuefun_1 (toErl 1)) =
  EXC.tryOfCatch
    (\ _ ->
       BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [list0_2])
    (\ of_4 ->
       let arg_11 = ErlangMap Map.empty
       in
         erlps__groups_from_list_2__4 [fun_0, valuefun_1, of_4, arg_11])
    (\ ex_5 ->
       case ex_5 of
         (ErlangTuple [(ErlangAtom "error"), _, _]) ->
           erlps__badarg_with_info__1
             [ErlangCons fun_0
                (ErlangCons valuefun_1 (ErlangCons list0_2 ErlangEmptyList))]
         ex_6 -> EXC.raise ex_6)
erlps__groups_from_list__3 [fun_0, valuefun_1, list_2] =
  erlps__badarg_with_info__1
    [ErlangCons fun_0
       (ErlangCons valuefun_1 (ErlangCons list_2 ErlangEmptyList))]
erlps__groups_from_list__3 [arg_10, arg_11, arg_12] =
  EXC.function_clause unit
erlps__groups_from_list__3 args =
  EXC.badarity (ErlangFun 3 erlps__groups_from_list__3) args

erlps__groups_from_list_2__4 :: ErlangFun
erlps__groups_from_list_2__4 [fun_0, valuefun_1,
                              (ErlangCons h_2 tail_3), acc_4]
  =
  let   
    k_7 =
      BIF.erlang__apply__2 [fun_0, ErlangCons h_2 ErlangEmptyList]
  in let
    v_10 =
      BIF.erlang__apply__2 [valuefun_1, ErlangCons h_2 ErlangEmptyList]
  in let
    newacc_30 =
      case acc_4 of
        (ErlangMap map_12) | (DM.Just vs_13) <-
                               (Map.lookup k_7 map_12) ->
          let
            mapExt_19 = ErlangMap (Map.singleton k_7 (ErlangCons v_10 vs_13))
          in
            case findMissingKey acc_4 [k_7] of
              (DM.Nothing) -> BIF.maps__merge__2 [acc_4, mapExt_19]
              (DM.Just missing_21) -> EXC.badkey missing_21
        (ErlangMap map_22) ->
          let
            mapExt_28 =
              ErlangMap (Map.singleton k_7 (ErlangCons v_10 ErlangEmptyList))
          in BIF.maps__merge__2 [acc_4, mapExt_28]
        something_else -> EXC.case_clause something_else
  in
    erlps__groups_from_list_2__4
      [fun_0, valuefun_1, tail_3, newacc_30]
erlps__groups_from_list_2__4 [_fun_0, _valuefun_1,
                              (ErlangEmptyList), acc_2]
  =
  acc_2
erlps__groups_from_list_2__4 [arg_3, arg_4, arg_5, arg_6] =
  EXC.function_clause unit
erlps__groups_from_list_2__4 args =
  EXC.badarity (ErlangFun 4 erlps__groups_from_list_2__4) args

erlps__error_type__1 :: ErlangFun
erlps__error_type__1 [m_0] | isEMap m_0 = ErlangAtom "badarg"
erlps__error_type__1 [v_0] =
  ErlangTuple [ErlangAtom "badmap", v_0]
erlps__error_type__1 [arg_3] = EXC.function_clause unit
erlps__error_type__1 args =
  EXC.badarity (ErlangFun 1 erlps__error_type__1) args

erlps__error_type_two_maps__2 :: ErlangFun
erlps__error_type_two_maps__2 [m1_0, m2_1] | isEMap m1_0 =
  ErlangTuple [ErlangAtom "badmap", m2_1]
erlps__error_type_two_maps__2 [m1_0, _m2_1] =
  ErlangTuple [ErlangAtom "badmap", m1_0]
erlps__error_type_two_maps__2 [arg_4, arg_5] =
  EXC.function_clause unit
erlps__error_type_two_maps__2 args =
  EXC.badarity (ErlangFun 2 erlps__error_type_two_maps__2) args

erlps__error_type_merge_intersect__3 :: ErlangFun
erlps__error_type_merge_intersect__3 [m1_0, m2_1, combiner_2]
  | isEFunA combiner_2 (toErl 3) =
  erlps__error_type_two_maps__2 [m1_0, m2_1]
erlps__error_type_merge_intersect__3 [_m1_0, _m2_1, _combiner_2]
  =
  ErlangAtom "badarg"
erlps__error_type_merge_intersect__3 [arg_3, arg_4, arg_5] =
  EXC.function_clause unit
erlps__error_type_merge_intersect__3 args =
  EXC.badarity (ErlangFun 3 erlps__error_type_merge_intersect__3)
    args

erlps__badarg_with_info__1 :: ErlangFun
erlps__badarg_with_info__1 [args_0] =
  let   
    tup_el_6 =
      ErlangMap
        (Map.singleton (ErlangAtom "module")
           (ErlangAtom "erl_stdlib_errors"))
  in let head_4 = ErlangTuple [ErlangAtom "error_info", tup_el_6]
  in
    BIF.erlang__error__3
      [ErlangAtom "badarg", args_0, ErlangCons head_4 ErlangEmptyList]
erlps__badarg_with_info__1 [arg_10] = EXC.function_clause unit
erlps__badarg_with_info__1 args =
  EXC.badarity (ErlangFun 1 erlps__badarg_with_info__1) args

erlps__error_with_info__2 :: ErlangFun
erlps__error_with_info__2 [reason_0, args_1] =
  let   
    tup_el_7 =
      ErlangMap
        (Map.singleton (ErlangAtom "module")
           (ErlangAtom "erl_stdlib_errors"))
  in let head_5 = ErlangTuple [ErlangAtom "error_info", tup_el_7]
  in
    BIF.erlang__error__3
      [reason_0, args_1, ErlangCons head_5 ErlangEmptyList]
erlps__error_with_info__2 [arg_11, arg_12] =
  EXC.function_clause unit
erlps__error_with_info__2 args =
  EXC.badarity (ErlangFun 2 erlps__error_with_info__2) args