module Sets(erlps__new__0, erlps__is_set__1, erlps__size__1,
            erlps__is_empty__1, erlps__to_list__1, erlps__from_list__1,
            erlps__is_element__2, erlps__add_element__2,
            erlps__del_element__2, erlps__union__2, erlps__union__1,
            erlps__intersection__2, erlps__intersection__1,
            erlps__is_disjoint__2, erlps__subtract__2, erlps__is_subset__2,
            erlps__fold__3, erlps__filter__2, erlps__new__1,
            erlps__from_list__2) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__new__0 :: ErlangFun
erlps__new__0 [] =
  let    arg_0 = toErl 16
  in let empty_1 = erlps__mk_seg__1 [arg_0]
  in let tup_el_3 = toErl 0
  in let tup_el_4 = toErl 16
  in let tup_el_5 = toErl 16
  in let lop_7 = toErl 16
  in let rop_8 = toErl 2
  in let tup_el_6 = BIF.erlang__op_div_strict [lop_7, rop_8]
  in let lop_10 = toErl 16
  in let rop_11 = toErl 5
  in let tup_el_9 = BIF.erlang__op_mult [lop_10, rop_11]
  in let lop_13 = toErl 16
  in let rop_14 = toErl 3
  in let tup_el_12 = BIF.erlang__op_mult [lop_13, rop_14]
  in let tup_el_16 = ErlangTuple [empty_1]
  in
    ErlangTuple
      [ErlangAtom "set", tup_el_3, tup_el_4, tup_el_5, tup_el_6,
       tup_el_9, tup_el_12, empty_1, tup_el_16]
erlps__new__0 args =
  EXC.badarity (ErlangFun 0 erlps__new__0) args

erlps__new__1 :: ErlangFun
erlps__new__1 [(ErlangCons (ErlangTuple [(ErlangAtom "version"),
                                         (ErlangInt num_0)]) (ErlangEmptyList))]
  | (ErlangInt num_0) == (toErl 2) =
  ErlangMap Map.empty
erlps__new__1 [opts_0] =
  let    arg_4 = toErl 1
  in let
    case_1 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "version", opts_0, arg_4]
  in
    case case_1 of
      (ErlangInt num_5) | (ErlangInt num_5) == (toErl 1) ->
        erlps__new__0 []
      (ErlangInt num_6) | (ErlangInt num_6) == (toErl 2) ->
        let    tup_el_10 = toErl 2
        in let head_8 = ErlangTuple [ErlangAtom "version", tup_el_10]
        in erlps__new__1 [ErlangCons head_8 ErlangEmptyList]
      something_else -> EXC.case_clause something_else
erlps__new__1 [arg_12] = EXC.function_clause unit
erlps__new__1 args =
  EXC.badarity (ErlangFun 1 erlps__new__1) args

erlps__from_list__1 :: ErlangFun
erlps__from_list__1 [ls_0] =
  let   
    arg_1 =
      ErlangFun 2
        (let
           lambda_2 [e_5, s_6] = erlps__add_element__2 [e_5, s_6]
           lambda_2 [arg_3, arg_4] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 2 lambda_2) args
         in lambda_2)
  in let arg_9 = erlps__new__0 []
  in
    BIF.do_remote_fun_call "Lists" "erlps__foldl__3"
      [arg_1, arg_9, ls_0]
erlps__from_list__1 [arg_11] = EXC.function_clause unit
erlps__from_list__1 args =
  EXC.badarity (ErlangFun 1 erlps__from_list__1) args

erlps__from_list__2 :: ErlangFun
erlps__from_list__2 [ls_0,
                     (ErlangCons (ErlangTuple [(ErlangAtom "version"),
                                               (ErlangInt num_1)]) (ErlangEmptyList))]
  | (ErlangInt num_1) == (toErl 2) =
  BIF.do_remote_fun_call "Maps" "erlps__from_keys__2"
    [ls_0, ErlangEmptyList]
erlps__from_list__2 [ls_0, opts_1] =
  let    arg_5 = toErl 1
  in let
    case_2 =
      BIF.do_remote_fun_call "Proplists" "erlps__get_value__3"
        [ErlangAtom "version", opts_1, arg_5]
  in
    case case_2 of
      (ErlangInt num_6) | (ErlangInt num_6) == (toErl 1) ->
        erlps__from_list__1 [ls_0]
      (ErlangInt num_8) | (ErlangInt num_8) == (toErl 2) ->
        let    tup_el_13 = toErl 2
        in let head_11 = ErlangTuple [ErlangAtom "version", tup_el_13]
        in erlps__from_list__2 [ls_0, ErlangCons head_11 ErlangEmptyList]
      something_else -> EXC.case_clause something_else
erlps__from_list__2 [arg_15, arg_16] = EXC.function_clause unit
erlps__from_list__2 args =
  EXC.badarity (ErlangFun 2 erlps__from_list__2) args

erlps__is_set__1 :: ErlangFun
erlps__is_set__1 [(ErlangMap map_0)] = ErlangAtom "true"
erlps__is_set__1 [(ErlangTuple [(ErlangAtom "set"), _, _, _, _,
                                _, _, _, _])]
  =
  ErlangAtom "true"
erlps__is_set__1 [_] = ErlangAtom "false"
erlps__is_set__1 [arg_0] = EXC.function_clause unit
erlps__is_set__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_set__1) args

erlps__size__1 :: ErlangFun
erlps__size__1 [s_1@(ErlangMap map_0)] =
  BIF.erlang__map_size__1 [s_1]
erlps__size__1 [(ErlangTuple [(ErlangAtom "set"), size_0, _, _,
                              _, _, _, _, _])]
  =
  size_0
erlps__size__1 [arg_1] = EXC.function_clause unit
erlps__size__1 args =
  EXC.badarity (ErlangFun 1 erlps__size__1) args

erlps__is_empty__1 :: ErlangFun
erlps__is_empty__1 [s_1@(ErlangMap map_0)] =
  let    lop_2 = BIF.erlang__map_size__1 [s_1]
  in let rop_4 = toErl 0
  in BIF.erlang__op_exactEq [lop_2, rop_4]
erlps__is_empty__1 [(ErlangTuple [(ErlangAtom "set"), size_0, _,
                                  _, _, _, _, _, _])]
  =
  let rop_2 = toErl 0
  in BIF.erlang__op_exactEq [size_0, rop_2]
erlps__is_empty__1 [arg_3] = EXC.function_clause unit
erlps__is_empty__1 args =
  EXC.badarity (ErlangFun 1 erlps__is_empty__1) args

erlps__to_list__1 :: ErlangFun
erlps__to_list__1 [s_1@(ErlangMap map_0)] =
  BIF.maps__keys__1 [s_1]
erlps__to_list__1 [s_0@(ErlangTuple [(ErlangAtom "set"), _, _, _,
                                     _, _, _, _, _])]
  =
  let
    arg_1 =
      ErlangFun 2
        (let
           lambda_2 [elem_5, list_6] = ErlangCons elem_5 list_6
           lambda_2 [arg_3, arg_4] = EXC.function_clause unit
           lambda_2 args = EXC.badarity (ErlangFun 2 lambda_2) args
         in lambda_2)
  in erlps__fold__3 [arg_1, ErlangEmptyList, s_0]
erlps__to_list__1 [arg_11] = EXC.function_clause unit
erlps__to_list__1 args =
  EXC.badarity (ErlangFun 1 erlps__to_list__1) args

erlps__is_element__2 :: ErlangFun
erlps__is_element__2 [e_0, s_2@(ErlangMap map_1)] =
  case s_2 of
    (ErlangMap map_4) | (DM.Just _) <- (Map.lookup e_0 map_4) ->
      ErlangAtom "true"
    _ -> ErlangAtom "false"
erlps__is_element__2 [e_0,
                      s_1@(ErlangTuple [(ErlangAtom "set"), _, _, _, _, _, _, _,
                                        _])]
  =
  let    slot_4 = erlps__get_slot__2 [s_1, e_0]
  in let bkt_7 = erlps__get_bucket__2 [s_1, slot_4]
  in BIF.lists__member__2 [e_0, bkt_7]
erlps__is_element__2 [arg_10, arg_11] = EXC.function_clause unit
erlps__is_element__2 args =
  EXC.badarity (ErlangFun 2 erlps__is_element__2) args

erlps__add_element__2 :: ErlangFun
erlps__add_element__2 [e_0, s_2@(ErlangMap map_1)] =
  let mapExt_6 = ErlangMap (Map.singleton e_0 ErlangEmptyList)
  in BIF.maps__merge__2 [s_2, mapExt_6]
erlps__add_element__2 [e_0,
                       s0_1@(ErlangTuple [(ErlangAtom "set"), _, _, _, _, _, _,
                                          _, _])]
  =
  let    slot_4 = erlps__get_slot__2 [s0_1, e_0]
  in let bkt_7 = erlps__get_bucket__2 [s0_1, slot_4]
  in let case_8 = BIF.lists__member__2 [e_0, bkt_7]
  in
    case case_8 of
      (ErlangAtom "true") -> s0_1
      (ErlangAtom "false") ->
        let
          s1_16 =
            erlps__update_bucket__3 [s0_1, slot_4, ErlangCons e_0 bkt_7]
        in erlps__maybe_expand__1 [s1_16]
      something_else -> EXC.case_clause something_else
erlps__add_element__2 [arg_18, arg_19] = EXC.function_clause unit
erlps__add_element__2 args =
  EXC.badarity (ErlangFun 2 erlps__add_element__2) args

erlps__del_element__2 :: ErlangFun
erlps__del_element__2 [e_0, s_2@(ErlangMap map_1)] =
  BIF.maps__remove__2 [e_0, s_2]
erlps__del_element__2 [e_0,
                       s0_1@(ErlangTuple [(ErlangAtom "set"), _, _, _, _, _, _,
                                          _, _])]
  =
  let    slot_4 = erlps__get_slot__2 [s0_1, e_0]
  in let bkt_7 = erlps__get_bucket__2 [s0_1, slot_4]
  in let case_8 = BIF.lists__member__2 [e_0, bkt_7]
  in
    case case_8 of
      (ErlangAtom "false") -> s0_1
      (ErlangAtom "true") ->
        let   
          arg_13 =
            BIF.do_remote_fun_call "Lists" "erlps__delete__2" [e_0, bkt_7]
        in let s1_16 = erlps__update_bucket__3 [s0_1, slot_4, arg_13]
        in let arg_18 = toErl 1
        in erlps__maybe_contract__2 [s1_16, arg_18]
      something_else -> EXC.case_clause something_else
erlps__del_element__2 [arg_19, arg_20] = EXC.function_clause unit
erlps__del_element__2 args =
  EXC.badarity (ErlangFun 2 erlps__del_element__2) args

erlps__update_bucket__3 :: ErlangFun
erlps__update_bucket__3 [set_0, slot_1, newbucket_2] =
  let    rop_6 = toErl 1
  in let lop_4 = BIF.erlang__op_minus [slot_1, rop_6]
  in let rop_7 = toErl 16
  in let lop_3 = BIF.erlang__op_div_strict [lop_4, rop_7]
  in let rop_8 = toErl 1
  in let segi_9 = BIF.erlang__op_plus [lop_3, rop_8]
  in let rop_13 = toErl 1
  in let lop_11 = BIF.erlang__op_minus [slot_1, rop_13]
  in let rop_14 = toErl 16
  in let lop_10 = BIF.erlang__op_rem_strict [lop_11, rop_14]
  in let rop_15 = toErl 1
  in let bkti_16 = BIF.erlang__op_plus [lop_10, rop_15]
  in let
    segs_20 =
      case set_0 of
        (ErlangTuple arr_19) | (DM.Just field_18) <- (arr_19 DA.!! 8) ->
          field_18
        _ -> EXC.badrecord (ErlangAtom "set")
  in let seg_23 = BIF.erlang__element__2 [segi_9, segs_20]
  in let
    arg_28 = BIF.erlang__setelement__3 [bkti_16, seg_23, newbucket_2]
  in let
    record_updt_25 =
      BIF.erlang__setelement__3 [segi_9, segs_20, arg_28]
  in
    case set_0 of
      (ErlangTuple [(ErlangAtom "set"), size_32, n_33, maxn_34, bso_35,
                    exp_size_36, con_size_37, empty_38, segs_39]) ->
        ErlangTuple
          [ErlangAtom "set", size_32, n_33, maxn_34, bso_35, exp_size_36,
           con_size_37, empty_38, record_updt_25]
      _ -> EXC.badrecord (ErlangAtom "set")
erlps__update_bucket__3 [arg_40, arg_41, arg_42] =
  EXC.function_clause unit
erlps__update_bucket__3 args =
  EXC.badarity (ErlangFun 3 erlps__update_bucket__3) args

erlps__union__2 :: ErlangFun
erlps__union__2 [s1_1@(ErlangMap map_0), s2_3@(ErlangMap map_2)]
  =
  BIF.maps__merge__2 [s1_1, s2_3]
erlps__union__2 [s1_0, s2_1] =
  let    lop_3 = erlps__size__1 [s1_0]
  in let rop_5 = erlps__size__1 [s2_1]
  in let case_2 = BIF.erlang__op_lesser [lop_3, rop_5]
  in
    case case_2 of
      (ErlangAtom "true") ->
        let
          arg_7 =
            ErlangFun 2
              (let
                 lambda_8 [e_11, s_12] = erlps__add_element__2 [e_11, s_12]
                 lambda_8 [arg_9, arg_10] = EXC.function_clause unit
                 lambda_8 args = EXC.badarity (ErlangFun 2 lambda_8) args
               in lambda_8)
        in erlps__fold__3 [arg_7, s2_1, s1_0]
      (ErlangAtom "false") ->
        let
          arg_17 =
            ErlangFun 2
              (let
                 lambda_18 [e_21, s_22] = erlps__add_element__2 [e_21, s_22]
                 lambda_18 [arg_19, arg_20] = EXC.function_clause unit
                 lambda_18 args = EXC.badarity (ErlangFun 2 lambda_18) args
               in lambda_18)
        in erlps__fold__3 [arg_17, s1_0, s2_1]
      something_else -> EXC.case_clause something_else
erlps__union__2 [arg_27, arg_28] = EXC.function_clause unit
erlps__union__2 args =
  EXC.badarity (ErlangFun 2 erlps__union__2) args

erlps__union__1 :: ErlangFun
erlps__union__1 [(ErlangCons s1_0 (ErlangCons s2_1 ss_2))] =
  let arg_3 = erlps__union__2 [s1_0, s2_1]
  in erlps__union1__2 [arg_3, ss_2]
erlps__union__1 [(ErlangCons s_0 (ErlangEmptyList))] = s_0
erlps__union__1 [(ErlangEmptyList)] = erlps__new__0 []
erlps__union__1 [arg_0] = EXC.function_clause unit
erlps__union__1 args =
  EXC.badarity (ErlangFun 1 erlps__union__1) args

erlps__union1__2 :: ErlangFun
erlps__union1__2 [s1_0, (ErlangCons s2_1 ss_2)] =
  let arg_3 = erlps__union__2 [s1_0, s2_1]
  in erlps__union1__2 [arg_3, ss_2]
erlps__union1__2 [s1_0, (ErlangEmptyList)] = s1_0
erlps__union1__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__union1__2 args =
  EXC.badarity (ErlangFun 2 erlps__union1__2) args

erlps__intersection__2 :: ErlangFun
erlps__intersection__2 [s1_1@(ErlangMap map_0),
                        s2_3@(ErlangMap map_2)]
  =
  let    lop_5 = BIF.erlang__map_size__1 [s1_1]
  in let rop_7 = BIF.erlang__map_size__1 [s2_3]
  in let case_4 = BIF.erlang__op_lesser [lop_5, rop_7]
  in
    case case_4 of
      (ErlangAtom "true") ->
        let   
          arg_9 = BIF.do_remote_fun_call "Maps" "erlps__iterator__1" [s1_1]
        in let
          next_11 = BIF.do_remote_fun_call "Maps" "erlps__next__1" [arg_9]
        in let lop_17 = BIF.erlang__map_size__1 [s1_1]
        in let rop_19 = ErlangFloat 7.50000000000000000000e-1
        in let arg_16 = BIF.erlang__op_mult [lop_17, rop_19]
        in let arg_15 = BIF.erlang__floor__1 [arg_16]
        in
          erlps__intersection_heuristic__6
            [next_11, ErlangEmptyList, ErlangEmptyList, arg_15, s1_1, s2_3]
      (ErlangAtom "false") ->
        let   
          arg_22 =
            BIF.do_remote_fun_call "Maps" "erlps__iterator__1" [s2_3]
        in let
          next_24 = BIF.do_remote_fun_call "Maps" "erlps__next__1" [arg_22]
        in let lop_30 = BIF.erlang__map_size__1 [s2_3]
        in let rop_32 = ErlangFloat 7.50000000000000000000e-1
        in let arg_29 = BIF.erlang__op_mult [lop_30, rop_32]
        in let arg_28 = BIF.erlang__floor__1 [arg_29]
        in
          erlps__intersection_heuristic__6
            [next_24, ErlangEmptyList, ErlangEmptyList, arg_28, s2_3, s1_1]
      something_else -> EXC.case_clause something_else
erlps__intersection__2 [s1_0, s2_1] =
  let    lop_3 = erlps__size__1 [s1_0]
  in let rop_5 = erlps__size__1 [s2_1]
  in let case_2 = BIF.erlang__op_lesser [lop_3, rop_5]
  in
    case case_2 of
      (ErlangAtom "true") ->
        let
          arg_7 =
            ErlangFun 1
              (let
                 lambda_8 [e_10] = erlps__is_element__2 [e_10, s2_1]
                 lambda_8 [arg_9] = EXC.function_clause unit
                 lambda_8 args = EXC.badarity (ErlangFun 1 lambda_8) args
               in lambda_8)
        in erlps__filter__2 [arg_7, s1_0]
      (ErlangAtom "false") ->
        let
          arg_14 =
            ErlangFun 1
              (let
                 lambda_15 [e_17] = erlps__is_element__2 [e_17, s1_0]
                 lambda_15 [arg_16] = EXC.function_clause unit
                 lambda_15 args = EXC.badarity (ErlangFun 1 lambda_15) args
               in lambda_15)
        in erlps__filter__2 [arg_14, s2_1]
      something_else -> EXC.case_clause something_else
erlps__intersection__2 [arg_21, arg_22] =
  EXC.function_clause unit
erlps__intersection__2 args =
  EXC.badarity (ErlangFun 2 erlps__intersection__2) args

erlps__intersection_heuristic__6 :: ErlangFun
erlps__intersection_heuristic__6 [next_0, _keep_1, delete_2,
                                  (ErlangInt num_3), acc_4, reference_5]
  | (ErlangInt num_3) == (toErl 0) =
  let arg_7 = erlps__remove_keys__2 [delete_2, acc_4]
  in erlps__intersection_decided__3 [next_0, arg_7, reference_5]
erlps__intersection_heuristic__6 [(ErlangTuple [key_0, _value_1,
                                                iterator_2]),
                                  keep_3, delete_4, keepcount_5, acc_6,
                                  reference_7]
  =
  let
    next_9 =
      BIF.do_remote_fun_call "Maps" "erlps__next__1" [iterator_2]
  in
    case reference_7 of
      (ErlangMap map_11) | (DM.Just _) <- (Map.lookup key_0 map_11) ->
        let    rop_19 = toErl 1
        in let arg_17 = BIF.erlang__op_minus [keepcount_5, rop_19]
        in
          erlps__intersection_heuristic__6
            [next_9, ErlangCons key_0 keep_3, delete_4, arg_17, acc_6,
             reference_7]
      _ ->
        erlps__intersection_heuristic__6
          [next_9, keep_3, ErlangCons key_0 delete_4, keepcount_5, acc_6,
           reference_7]
erlps__intersection_heuristic__6 [(ErlangAtom "none"), keep_0,
                                  _delete_1, _count_2, _acc_3, _reference_4]
  =
  BIF.do_remote_fun_call "Maps" "erlps__from_keys__2"
    [keep_0, ErlangEmptyList]
erlps__intersection_heuristic__6 [arg_7, arg_8, arg_9, arg_10,
                                  arg_11, arg_12]
  =
  EXC.function_clause unit
erlps__intersection_heuristic__6 args =
  EXC.badarity (ErlangFun 6 erlps__intersection_heuristic__6) args

erlps__intersection_decided__3 :: ErlangFun
erlps__intersection_decided__3 [(ErlangTuple [key_0, _value_1,
                                              iterator_2]),
                                acc0_3, reference_4]
  =
  let   
    acc1_10 =
      case reference_4 of
        (ErlangMap map_6) | (DM.Just _) <- (Map.lookup key_0 map_6) ->
          acc0_3
        (ErlangMap map_7) -> BIF.maps__remove__2 [key_0, acc0_3]
        something_else -> EXC.case_clause something_else
  in let
    arg_11 =
      BIF.do_remote_fun_call "Maps" "erlps__next__1" [iterator_2]
  in erlps__intersection_decided__3 [arg_11, acc1_10, reference_4]
erlps__intersection_decided__3 [(ErlangAtom "none"), acc_0,
                                _reference_1]
  =
  acc_0
erlps__intersection_decided__3 [arg_2, arg_3, arg_4] =
  EXC.function_clause unit
erlps__intersection_decided__3 args =
  EXC.badarity (ErlangFun 3 erlps__intersection_decided__3) args

erlps__remove_keys__2 :: ErlangFun
erlps__remove_keys__2 [(ErlangCons k_0 ks_1), map_2] =
  let arg_4 = BIF.maps__remove__2 [k_0, map_2]
  in erlps__remove_keys__2 [ks_1, arg_4]
erlps__remove_keys__2 [(ErlangEmptyList), map_0] = map_0
erlps__remove_keys__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__remove_keys__2 args =
  EXC.badarity (ErlangFun 2 erlps__remove_keys__2) args

erlps__intersection__1 :: ErlangFun
erlps__intersection__1 [(ErlangCons s1_0 (ErlangCons s2_1 ss_2))]
  =
  let arg_3 = erlps__intersection__2 [s1_0, s2_1]
  in erlps__intersection1__2 [arg_3, ss_2]
erlps__intersection__1 [(ErlangCons s_0 (ErlangEmptyList))] = s_0
erlps__intersection__1 [arg_1] = EXC.function_clause unit
erlps__intersection__1 args =
  EXC.badarity (ErlangFun 1 erlps__intersection__1) args

erlps__intersection1__2 :: ErlangFun
erlps__intersection1__2 [s1_0, (ErlangCons s2_1 ss_2)] =
  let arg_3 = erlps__intersection__2 [s1_0, s2_1]
  in erlps__intersection1__2 [arg_3, ss_2]
erlps__intersection1__2 [s1_0, (ErlangEmptyList)] = s1_0
erlps__intersection1__2 [arg_1, arg_2] = EXC.function_clause unit
erlps__intersection1__2 args =
  EXC.badarity (ErlangFun 2 erlps__intersection1__2) args

erlps__is_disjoint__2 :: ErlangFun
erlps__is_disjoint__2 [s1_1@(ErlangMap map_0),
                       s2_3@(ErlangMap map_2)]
  =
  case ErlangAtom "true" of
    _ | (ErlangAtom "true") ==
          (falsifyErrors
             (\ _ ->
                let    lop_4 = BIF.erlang__map_size__1 [s1_1]
                in let rop_6 = BIF.erlang__map_size__1 [s2_3]
                in BIF.erlang__op_lesser [lop_4, rop_6])) ->
      let
        arg_9 = BIF.do_remote_fun_call "Maps" "erlps__iterator__1" [s1_1]
      in erlps__is_disjoint_1__2 [s2_3, arg_9]
    _ ->
      let
        arg_12 =
          BIF.do_remote_fun_call "Maps" "erlps__iterator__1" [s2_3]
      in erlps__is_disjoint_1__2 [s1_1, arg_12]
erlps__is_disjoint__2 [s1_0, s2_1] =
  let    lop_3 = erlps__size__1 [s1_0]
  in let rop_5 = erlps__size__1 [s2_1]
  in let case_2 = BIF.erlang__op_lesser [lop_3, rop_5]
  in
    case case_2 of
      (ErlangAtom "true") ->
        let
          arg_7 =
            ErlangFun 2
              (let
                 lambda_8 [_, (ErlangAtom "false")] = ErlangAtom "false"
                 lambda_8 [e_11, (ErlangAtom "true")] =
                   let op_arg_12 = erlps__is_element__2 [e_11, s2_1]
                   in BIF.erlang__not__1 [op_arg_12]
                 lambda_8 [arg_9, arg_10] = EXC.function_clause unit
                 lambda_8 args = EXC.badarity (ErlangFun 2 lambda_8) args
               in lambda_8)
        in erlps__fold__3 [arg_7, ErlangAtom "true", s1_0]
      (ErlangAtom "false") ->
        let
          arg_17 =
            ErlangFun 2
              (let
                 lambda_18 [_, (ErlangAtom "false")] = ErlangAtom "false"
                 lambda_18 [e_21, (ErlangAtom "true")] =
                   let op_arg_22 = erlps__is_element__2 [e_21, s1_0]
                   in BIF.erlang__not__1 [op_arg_22]
                 lambda_18 [arg_19, arg_20] = EXC.function_clause unit
                 lambda_18 args = EXC.badarity (ErlangFun 2 lambda_18) args
               in lambda_18)
        in erlps__fold__3 [arg_17, ErlangAtom "true", s2_1]
      something_else -> EXC.case_clause something_else
erlps__is_disjoint__2 [arg_27, arg_28] = EXC.function_clause unit
erlps__is_disjoint__2 args =
  EXC.badarity (ErlangFun 2 erlps__is_disjoint__2) args

erlps__is_disjoint_1__2 :: ErlangFun
erlps__is_disjoint_1__2 [set_0, iter_1] =
  let
    case_2 = BIF.do_remote_fun_call "Maps" "erlps__next__1" [iter_1]
  in
    case case_2 of
      (ErlangTuple [k_4, _, nextiter_5]) ->
        case set_0 of
          (ErlangMap map_7) | (DM.Just _) <- (Map.lookup k_4 map_7) ->
            ErlangAtom "false"
          (ErlangMap map_8) -> erlps__is_disjoint_1__2 [set_0, nextiter_5]
          something_else -> EXC.case_clause something_else
      (ErlangAtom "none") -> ErlangAtom "true"
      something_else -> EXC.case_clause something_else
erlps__is_disjoint_1__2 [arg_11, arg_12] =
  EXC.function_clause unit
erlps__is_disjoint_1__2 args =
  EXC.badarity (ErlangFun 2 erlps__is_disjoint_1__2) args

erlps__subtract__2 :: ErlangFun
erlps__subtract__2 [s1_1@(ErlangMap map_0),
                    s2_3@(ErlangMap map_2)]
  =
  let   
    arg_4 = BIF.do_remote_fun_call "Maps" "erlps__iterator__1" [s1_1]
  in let
    next_6 = BIF.do_remote_fun_call "Maps" "erlps__next__1" [arg_4]
  in let lop_12 = BIF.erlang__map_size__1 [s1_1]
  in let rop_14 = ErlangFloat 7.50000000000000000000e-1
  in let arg_11 = BIF.erlang__op_mult [lop_12, rop_14]
  in let arg_10 = BIF.erlang__floor__1 [arg_11]
  in
    erlps__subtract_heuristic__6
      [next_6, ErlangEmptyList, ErlangEmptyList, arg_10, s1_1, s2_3]
erlps__subtract__2 [s1_0, s2_1] =
  let
    arg_2 =
      ErlangFun 1
        (let
           lambda_3 [e_5] =
             let op_arg_6 = erlps__is_element__2 [e_5, s2_1]
             in BIF.erlang__not__1 [op_arg_6]
           lambda_3 [arg_4] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 1 lambda_3) args
         in lambda_3)
  in erlps__filter__2 [arg_2, s1_0]
erlps__subtract__2 [arg_10, arg_11] = EXC.function_clause unit
erlps__subtract__2 args =
  EXC.badarity (ErlangFun 2 erlps__subtract__2) args

erlps__subtract_heuristic__6 :: ErlangFun
erlps__subtract_heuristic__6 [next_0, _keep_1, delete_2,
                              (ErlangInt num_3), acc_4, reference_5]
  | (ErlangInt num_3) == (toErl 0) =
  let arg_7 = erlps__remove_keys__2 [delete_2, acc_4]
  in erlps__subtract_decided__3 [next_0, arg_7, reference_5]
erlps__subtract_heuristic__6 [(ErlangTuple [key_0, _value_1,
                                            iterator_2]),
                              keep_3, delete_4, keepcount_5, acc_6, reference_7]
  =
  let
    next_9 =
      BIF.do_remote_fun_call "Maps" "erlps__next__1" [iterator_2]
  in
    case reference_7 of
      (ErlangMap map_11) | (DM.Just _) <- (Map.lookup key_0 map_11) ->
        erlps__subtract_heuristic__6
          [next_9, keep_3, ErlangCons key_0 delete_4, keepcount_5, acc_6,
           reference_7]
      _ ->
        let    rop_27 = toErl 1
        in let arg_25 = BIF.erlang__op_minus [keepcount_5, rop_27]
        in
          erlps__subtract_heuristic__6
            [next_9, ErlangCons key_0 keep_3, delete_4, arg_25, acc_6,
             reference_7]
erlps__subtract_heuristic__6 [(ErlangAtom "none"), keep_0,
                              _delete_1, _count_2, _acc_3, _reference_4]
  =
  BIF.do_remote_fun_call "Maps" "erlps__from_keys__2"
    [keep_0, ErlangEmptyList]
erlps__subtract_heuristic__6 [arg_7, arg_8, arg_9, arg_10,
                              arg_11, arg_12]
  =
  EXC.function_clause unit
erlps__subtract_heuristic__6 args =
  EXC.badarity (ErlangFun 6 erlps__subtract_heuristic__6) args

erlps__subtract_decided__3 :: ErlangFun
erlps__subtract_decided__3 [(ErlangTuple [key_0, _value_1,
                                          iterator_2]),
                            acc_3, reference_4]
  =
  case reference_4 of
    (ErlangMap map_6) | (DM.Just _) <- (Map.lookup key_0 map_6) ->
      let   
        arg_7 =
          BIF.do_remote_fun_call "Maps" "erlps__next__1" [iterator_2]
      in let arg_9 = BIF.maps__remove__2 [key_0, acc_3]
      in erlps__subtract_decided__3 [arg_7, arg_9, reference_4]
    _ ->
      let
        arg_13 =
          BIF.do_remote_fun_call "Maps" "erlps__next__1" [iterator_2]
      in erlps__subtract_decided__3 [arg_13, acc_3, reference_4]
erlps__subtract_decided__3 [(ErlangAtom "none"), acc_0,
                            _reference_1]
  =
  acc_0
erlps__subtract_decided__3 [arg_2, arg_3, arg_4] =
  EXC.function_clause unit
erlps__subtract_decided__3 args =
  EXC.badarity (ErlangFun 3 erlps__subtract_decided__3) args

erlps__is_subset__2 :: ErlangFun
erlps__is_subset__2 [s1_1@(ErlangMap map_0),
                     s2_3@(ErlangMap map_2)]
  =
  case ErlangAtom "true" of
    _ | (ErlangAtom "true") ==
          (falsifyErrors
             (\ _ ->
                let    lop_4 = BIF.erlang__map_size__1 [s1_1]
                in let rop_6 = BIF.erlang__map_size__1 [s2_3]
                in BIF.erlang__op_greater [lop_4, rop_6])) ->
      ErlangAtom "false"
    _ ->
      let
        arg_9 = BIF.do_remote_fun_call "Maps" "erlps__iterator__1" [s1_1]
      in erlps__is_subset_1__2 [s2_3, arg_9]
erlps__is_subset__2 [s1_0, s2_1] =
  let
    arg_2 =
      ErlangFun 2
        (let
           lambda_3 [e_6, sub_7] =
             case sub_7 of
               (ErlangAtom "false") -> ErlangAtom "false"
               (ErlangAtom "true") -> erlps__is_element__2 [e_6, s2_1]
               _ -> EXC.badarg1 sub_7
           lambda_3 [arg_4, arg_5] = EXC.function_clause unit
           lambda_3 args = EXC.badarity (ErlangFun 2 lambda_3) args
         in lambda_3)
  in erlps__fold__3 [arg_2, ErlangAtom "true", s1_0]
erlps__is_subset__2 [arg_13, arg_14] = EXC.function_clause unit
erlps__is_subset__2 args =
  EXC.badarity (ErlangFun 2 erlps__is_subset__2) args

erlps__is_subset_1__2 :: ErlangFun
erlps__is_subset_1__2 [set_0, iter_1] =
  let
    case_2 = BIF.do_remote_fun_call "Maps" "erlps__next__1" [iter_1]
  in
    case case_2 of
      (ErlangTuple [k_4, _, nextiter_5]) ->
        case set_0 of
          (ErlangMap map_7) | (DM.Just _) <- (Map.lookup k_4 map_7) ->
            erlps__is_subset_1__2 [set_0, nextiter_5]
          (ErlangMap map_10) -> ErlangAtom "false"
          something_else -> EXC.case_clause something_else
      (ErlangAtom "none") -> ErlangAtom "true"
      something_else -> EXC.case_clause something_else
erlps__is_subset_1__2 [arg_11, arg_12] = EXC.function_clause unit
erlps__is_subset_1__2 args =
  EXC.badarity (ErlangFun 2 erlps__is_subset_1__2) args

erlps__fold__3 :: ErlangFun
erlps__fold__3 [f_0, acc_1, d_3@(ErlangMap map_2)]
  | isEFunA f_0 (toErl 2) =
  let
    arg_6 = BIF.do_remote_fun_call "Maps" "erlps__iterator__1" [d_3]
  in erlps__fold_1__3 [f_0, acc_1, arg_6]
erlps__fold__3 [f_0, acc_1,
                d_2@(ErlangTuple [(ErlangAtom "set"), _, _, _, _, _, _, _, _])]
  | isEFunA f_0 (toErl 2) =
  erlps__fold_set__3 [f_0, acc_1, d_2]
erlps__fold__3 [arg_6, arg_7, arg_8] = EXC.function_clause unit
erlps__fold__3 args =
  EXC.badarity (ErlangFun 3 erlps__fold__3) args

erlps__fold_1__3 :: ErlangFun
erlps__fold_1__3 [fun_0, acc_1, iter_2] =
  let
    case_3 = BIF.do_remote_fun_call "Maps" "erlps__next__1" [iter_2]
  in
    case case_3 of
      (ErlangTuple [k_5, _, nextiter_6]) ->
        let
          arg_8 =
            BIF.erlang__apply__2
              [fun_0, ErlangCons k_5 (ErlangCons acc_1 ErlangEmptyList)]
        in erlps__fold_1__3 [fun_0, arg_8, nextiter_6]
      (ErlangAtom "none") -> acc_1
      something_else -> EXC.case_clause something_else
erlps__fold_1__3 [arg_13, arg_14, arg_15] =
  EXC.function_clause unit
erlps__fold_1__3 args =
  EXC.badarity (ErlangFun 3 erlps__fold_1__3) args

erlps__filter__2 :: ErlangFun
erlps__filter__2 [f_0, d_2@(ErlangMap map_1)]
  | isEFunA f_0 (toErl 1) =
  let   
    arg_5 = BIF.do_remote_fun_call "Maps" "erlps__iterator__1" [d_2]
  in let arg_3 = erlps__filter_1__2 [f_0, arg_5]
  in
    BIF.do_remote_fun_call "Maps" "erlps__from_keys__2"
      [arg_3, ErlangEmptyList]
erlps__filter__2 [f_0,
                  d_1@(ErlangTuple [(ErlangAtom "set"), _, _, _, _, _, _, _,
                                    _])]
  | isEFunA f_0 (toErl 1) =
  erlps__filter_set__2 [f_0, d_1]
erlps__filter__2 [arg_4, arg_5] = EXC.function_clause unit
erlps__filter__2 args =
  EXC.badarity (ErlangFun 2 erlps__filter__2) args

erlps__filter_1__2 :: ErlangFun
erlps__filter_1__2 [fun_0, iter_1] =
  let
    case_2 = BIF.do_remote_fun_call "Maps" "erlps__next__1" [iter_1]
  in
    case case_2 of
      (ErlangTuple [k_4, _, nextiter_5]) ->
        let
          case_6 =
            BIF.erlang__apply__2 [fun_0, ErlangCons k_4 ErlangEmptyList]
        in
          case case_6 of
            (ErlangAtom "true") ->
              let tail_10 = erlps__filter_1__2 [fun_0, nextiter_5]
              in ErlangCons k_4 tail_10
            (ErlangAtom "false") -> erlps__filter_1__2 [fun_0, nextiter_5]
            something_else -> EXC.case_clause something_else
      (ErlangAtom "none") -> ErlangEmptyList
      something_else -> EXC.case_clause something_else
erlps__filter_1__2 [arg_15, arg_16] = EXC.function_clause unit
erlps__filter_1__2 args =
  EXC.badarity (ErlangFun 2 erlps__filter_1__2) args

erlps__get_slot__2 :: ErlangFun
erlps__get_slot__2 [t_0, key_1] =
  let   
    arg_3 =
      case t_0 of
        (ErlangTuple arr_6) | (DM.Just field_5) <- (arr_6 DA.!! 3) ->
          field_5
        _ -> EXC.badrecord (ErlangAtom "set")
  in let h_7 = BIF.erlang__phash__2 [key_1, arg_3]
  in
    case ErlangAtom "true" of
      _ | (ErlangAtom "true") ==
            (falsifyErrors
               (\ _ ->
                  let
                    rop_9 =
                      case t_0 of
                        (ErlangTuple arr_12) | (DM.Just field_11) <-
                                                 (arr_12 DA.!! 2) ->
                          field_11
                        _ -> EXC.badrecord (ErlangAtom "set")
                  in BIF.erlang__op_greater [h_7, rop_9])) ->
        let
          rop_14 =
            case t_0 of
              (ErlangTuple arr_17) | (DM.Just field_16) <- (arr_17 DA.!! 4) ->
                field_16
              _ -> EXC.badrecord (ErlangAtom "set")
        in BIF.erlang__op_minus [h_7, rop_14]
      _ -> h_7
erlps__get_slot__2 [arg_18, arg_19] = EXC.function_clause unit
erlps__get_slot__2 args =
  EXC.badarity (ErlangFun 2 erlps__get_slot__2) args

erlps__get_bucket__2 :: ErlangFun
erlps__get_bucket__2 [t_0, slot_1] =
  let
    arg_2 =
      case t_0 of
        (ErlangTuple arr_5) | (DM.Just field_4) <- (arr_5 DA.!! 8) ->
          field_4
        _ -> EXC.badrecord (ErlangAtom "set")
  in erlps__get_bucket_s__2 [arg_2, slot_1]
erlps__get_bucket__2 [arg_7, arg_8] = EXC.function_clause unit
erlps__get_bucket__2 args =
  EXC.badarity (ErlangFun 2 erlps__get_bucket__2) args

erlps__fold_set__3 :: ErlangFun
erlps__fold_set__3 [f_0, acc_1, d_2] =
  let   
    segs_6 =
      case d_2 of
        (ErlangTuple arr_5) | (DM.Just field_4) <- (arr_5 DA.!! 8) ->
          field_4
        _ -> EXC.badrecord (ErlangAtom "set")
  in let arg_10 = BIF.erlang__tuple_size__1 [segs_6]
  in erlps__fold_segs__4 [f_0, acc_1, segs_6, arg_10]
erlps__fold_set__3 [arg_12, arg_13, arg_14] =
  EXC.function_clause unit
erlps__fold_set__3 args =
  EXC.badarity (ErlangFun 3 erlps__fold_set__3) args

erlps__fold_segs__4 :: ErlangFun
erlps__fold_segs__4 [f_0, acc_1, segs_2, i_3]
  | weakGeq i_3 (toErl 1) =
  let    seg_6 = BIF.erlang__element__2 [i_3, segs_2]
  in let arg_12 = BIF.erlang__tuple_size__1 [seg_6]
  in let arg_8 = erlps__fold_seg__4 [f_0, acc_1, seg_6, arg_12]
  in let rop_17 = toErl 1
  in let arg_15 = BIF.erlang__op_minus [i_3, rop_17]
  in erlps__fold_segs__4 [f_0, arg_8, segs_2, arg_15]
erlps__fold_segs__4 [_, acc_0, _, _] = acc_0
erlps__fold_segs__4 [arg_1, arg_2, arg_3, arg_4] =
  EXC.function_clause unit
erlps__fold_segs__4 args =
  EXC.badarity (ErlangFun 4 erlps__fold_segs__4) args

erlps__fold_seg__4 :: ErlangFun
erlps__fold_seg__4 [f_0, acc_1, seg_2, i_3]
  | weakGeq i_3 (toErl 1) =
  let    arg_8 = BIF.erlang__element__2 [i_3, seg_2]
  in let arg_5 = erlps__fold_bucket__3 [f_0, acc_1, arg_8]
  in let rop_14 = toErl 1
  in let arg_12 = BIF.erlang__op_minus [i_3, rop_14]
  in erlps__fold_seg__4 [f_0, arg_5, seg_2, arg_12]
erlps__fold_seg__4 [_, acc_0, _, _] = acc_0
erlps__fold_seg__4 [arg_1, arg_2, arg_3, arg_4] =
  EXC.function_clause unit
erlps__fold_seg__4 args =
  EXC.badarity (ErlangFun 4 erlps__fold_seg__4) args

erlps__fold_bucket__3 :: ErlangFun
erlps__fold_bucket__3 [f_0, acc_1, (ErlangCons e_2 bkt_3)] =
  let
    arg_5 =
      BIF.erlang__apply__2
        [f_0, ErlangCons e_2 (ErlangCons acc_1 ErlangEmptyList)]
  in erlps__fold_bucket__3 [f_0, arg_5, bkt_3]
erlps__fold_bucket__3 [_, acc_0, (ErlangEmptyList)] = acc_0
erlps__fold_bucket__3 [arg_1, arg_2, arg_3] =
  EXC.function_clause unit
erlps__fold_bucket__3 args =
  EXC.badarity (ErlangFun 3 erlps__fold_bucket__3) args

erlps__filter_set__2 :: ErlangFun
erlps__filter_set__2 [f_0, d_1] =
  let   
    arg_2 =
      case d_1 of
        (ErlangTuple arr_5) | (DM.Just field_4) <- (arr_5 DA.!! 8) ->
          field_4
        _ -> EXC.badrecord (ErlangAtom "set")
  in let segs0_6 = BIF.erlang__tuple_to_list__1 [arg_2]
  in let arg_10 = toErl 0
  in let
    matchExpr_13 =
      erlps__filter_seg_list__4 [f_0, segs0_6, ErlangEmptyList, arg_10]
  in
    case matchExpr_13 of
      (ErlangTuple [segs1_11, fc_12]) ->
        let    record_updt_16 = BIF.erlang__list_to_tuple__1 [segs1_11]
        in let
          arg_14 =
            case d_1 of
              (ErlangTuple [(ErlangAtom "set"), size_18, n_19, maxn_20, bso_21,
                            exp_size_22, con_size_23, empty_24, segs_25]) ->
                ErlangTuple
                  [ErlangAtom "set", size_18, n_19, maxn_20, bso_21,
                   exp_size_22, con_size_23, empty_24, record_updt_16]
              _ -> EXC.badrecord (ErlangAtom "set")
        in erlps__maybe_contract__2 [arg_14, fc_12]
      _ -> EXC.badmatch matchExpr_13
erlps__filter_set__2 [arg_27, arg_28] = EXC.function_clause unit
erlps__filter_set__2 args =
  EXC.badarity (ErlangFun 2 erlps__filter_set__2) args

erlps__filter_seg_list__4 :: ErlangFun
erlps__filter_seg_list__4 [f_0, (ErlangCons seg_1 segs_2), fss_3,
                           fc0_4]
  =
  let    bkts0_6 = BIF.erlang__tuple_to_list__1 [seg_1]
  in let
    matchExpr_13 =
      erlps__filter_bkt_list__4 [f_0, bkts0_6, ErlangEmptyList, fc0_4]
  in
    case matchExpr_13 of
      (ErlangTuple [bkts1_11, fc1_12]) ->
        let head_17 = BIF.erlang__list_to_tuple__1 [bkts1_11]
        in
          erlps__filter_seg_list__4
            [f_0, segs_2, ErlangCons head_17 fss_3, fc1_12]
      _ -> EXC.badmatch matchExpr_13
erlps__filter_seg_list__4 [_, (ErlangEmptyList), fss_0, fc_1] =
  let tup_el_2 = BIF.lists__reverse__2 [fss_0, ErlangEmptyList]
  in ErlangTuple [tup_el_2, fc_1]
erlps__filter_seg_list__4 [arg_6, arg_7, arg_8, arg_9] =
  EXC.function_clause unit
erlps__filter_seg_list__4 args =
  EXC.badarity (ErlangFun 4 erlps__filter_seg_list__4) args

erlps__filter_bkt_list__4 :: ErlangFun
erlps__filter_bkt_list__4 [f_0, (ErlangCons bkt0_1 bkts_2),
                           fbs_3, fc0_4]
  =
  let
    matchExpr_11 =
      erlps__filter_bucket__4 [f_0, bkt0_1, ErlangEmptyList, fc0_4]
  in
    case matchExpr_11 of
      (ErlangTuple [bkt1_9, fc1_10]) ->
        erlps__filter_bkt_list__4
          [f_0, bkts_2, ErlangCons bkt1_9 fbs_3, fc1_10]
      _ -> EXC.badmatch matchExpr_11
erlps__filter_bkt_list__4 [_, (ErlangEmptyList), fbs_0, fc_1] =
  let
    tup_el_2 =
      BIF.do_remote_fun_call "Lists" "erlps__reverse__1" [fbs_0]
  in ErlangTuple [tup_el_2, fc_1]
erlps__filter_bkt_list__4 [arg_5, arg_6, arg_7, arg_8] =
  EXC.function_clause unit
erlps__filter_bkt_list__4 args =
  EXC.badarity (ErlangFun 4 erlps__filter_bkt_list__4) args

erlps__filter_bucket__4 :: ErlangFun
erlps__filter_bucket__4 [f_0, (ErlangCons e_1 bkt_2), fb_3, fc_4]
  =
  let
    case_5 =
      BIF.erlang__apply__2 [f_0, ErlangCons e_1 ErlangEmptyList]
  in
    case case_5 of
      (ErlangAtom "true") ->
        erlps__filter_bucket__4 [f_0, bkt_2, ErlangCons e_1 fb_3, fc_4]
      (ErlangAtom "false") ->
        let    rop_19 = toErl 1
        in let arg_17 = BIF.erlang__op_plus [fc_4, rop_19]
        in erlps__filter_bucket__4 [f_0, bkt_2, fb_3, arg_17]
      something_else -> EXC.case_clause something_else
erlps__filter_bucket__4 [_, (ErlangEmptyList), fb_0, fc_1] =
  ErlangTuple [fb_0, fc_1]
erlps__filter_bucket__4 [arg_4, arg_5, arg_6, arg_7] =
  EXC.function_clause unit
erlps__filter_bucket__4 args =
  EXC.badarity (ErlangFun 4 erlps__filter_bucket__4) args

erlps__get_bucket_s__2 :: ErlangFun
erlps__get_bucket_s__2 [segs_0, slot_1] =
  let    rop_5 = toErl 1
  in let lop_3 = BIF.erlang__op_minus [slot_1, rop_5]
  in let rop_6 = toErl 16
  in let lop_2 = BIF.erlang__op_div_strict [lop_3, rop_6]
  in let rop_7 = toErl 1
  in let segi_8 = BIF.erlang__op_plus [lop_2, rop_7]
  in let rop_12 = toErl 1
  in let lop_10 = BIF.erlang__op_minus [slot_1, rop_12]
  in let rop_13 = toErl 16
  in let lop_9 = BIF.erlang__op_rem_strict [lop_10, rop_13]
  in let rop_14 = toErl 1
  in let bkti_15 = BIF.erlang__op_plus [lop_9, rop_14]
  in let arg_17 = BIF.erlang__element__2 [segi_8, segs_0]
  in BIF.erlang__element__2 [bkti_15, arg_17]
erlps__get_bucket_s__2 [arg_20, arg_21] =
  EXC.function_clause unit
erlps__get_bucket_s__2 args =
  EXC.badarity (ErlangFun 2 erlps__get_bucket_s__2) args

erlps__put_bucket_s__3 :: ErlangFun
erlps__put_bucket_s__3 [segs_0, slot_1, bkt_2] =
  let    rop_6 = toErl 1
  in let lop_4 = BIF.erlang__op_minus [slot_1, rop_6]
  in let rop_7 = toErl 16
  in let lop_3 = BIF.erlang__op_div_strict [lop_4, rop_7]
  in let rop_8 = toErl 1
  in let segi_9 = BIF.erlang__op_plus [lop_3, rop_8]
  in let rop_13 = toErl 1
  in let lop_11 = BIF.erlang__op_minus [slot_1, rop_13]
  in let rop_14 = toErl 16
  in let lop_10 = BIF.erlang__op_rem_strict [lop_11, rop_14]
  in let rop_15 = toErl 1
  in let bkti_16 = BIF.erlang__op_plus [lop_10, rop_15]
  in let arg_18 = BIF.erlang__element__2 [segi_9, segs_0]
  in let
    seg_22 = BIF.erlang__setelement__3 [bkti_16, arg_18, bkt_2]
  in BIF.erlang__setelement__3 [segi_9, segs_0, seg_22]
erlps__put_bucket_s__3 [arg_26, arg_27, arg_28] =
  EXC.function_clause unit
erlps__put_bucket_s__3 args =
  EXC.badarity (ErlangFun 3 erlps__put_bucket_s__3) args

erlps__maybe_expand__1 :: ErlangFun
erlps__maybe_expand__1 [t0_0]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let   
              lop_65 =
                case t0_0 of
                  (ErlangTuple arr_68) | (DM.Just field_67) <-
                                           (arr_68 DA.!! 1) ->
                    field_67
                  _ -> EXC.badrecord (ErlangAtom "set")
            in let rop_69 = toErl 1
            in let lop_64 = BIF.erlang__op_plus [lop_65, rop_69]
            in let
              rop_70 =
                case t0_0 of
                  (ErlangTuple arr_73) | (DM.Just field_72) <-
                                           (arr_73 DA.!! 5) ->
                    field_72
                  _ -> EXC.badrecord (ErlangAtom "set")
            in BIF.erlang__op_greater [lop_64, rop_70])) =
  let    t_2 = erlps__maybe_expand_segs__1 [t0_0]
  in let
    lop_3 =
      case t_2 of
        (ErlangTuple arr_6) | (DM.Just field_5) <- (arr_6 DA.!! 2) ->
          field_5
        _ -> EXC.badrecord (ErlangAtom "set")
  in let rop_7 = toErl 1
  in let n_8 = BIF.erlang__op_plus [lop_3, rop_7]
  in let
    segs0_12 =
      case t_2 of
        (ErlangTuple arr_11) | (DM.Just field_10) <- (arr_11 DA.!! 8) ->
          field_10
        _ -> EXC.badrecord (ErlangAtom "set")
  in let
    rop_14 =
      case t_2 of
        (ErlangTuple arr_17) | (DM.Just field_16) <- (arr_17 DA.!! 4) ->
          field_16
        _ -> EXC.badrecord (ErlangAtom "set")
  in let slot1_18 = BIF.erlang__op_minus [n_8, rop_14]
  in let b_21 = erlps__get_bucket_s__2 [segs0_12, slot1_18]
  in let
    arg_26 =
      case t_2 of
        (ErlangTuple arr_29) | (DM.Just field_28) <- (arr_29 DA.!! 3) ->
          field_28
        _ -> EXC.badrecord (ErlangAtom "set")
  in let
    matchExpr_32 = erlps__rehash__4 [b_21, slot1_18, n_8, arg_26]
  in
    case matchExpr_32 of
      (ErlangTuple [b1_30, b2_31]) ->
        let   
          segs1_36 = erlps__put_bucket_s__3 [segs0_12, slot1_18, b1_30]
        in let segs2_40 = erlps__put_bucket_s__3 [segs1_36, n_8, b2_31]
        in let
          lop_43 =
            case t_2 of
              (ErlangTuple arr_46) | (DM.Just field_45) <- (arr_46 DA.!! 1) ->
                field_45
              _ -> EXC.badrecord (ErlangAtom "set")
        in let rop_47 = toErl 1
        in let record_updt_42 = BIF.erlang__op_plus [lop_43, rop_47]
        in let rop_51 = toErl 5
        in let record_updt_49 = BIF.erlang__op_mult [n_8, rop_51]
        in let rop_54 = toErl 3
        in let record_updt_52 = BIF.erlang__op_mult [n_8, rop_54]
        in
          case t_2 of
            (ErlangTuple [(ErlangAtom "set"), size_56, n_57, maxn_58, bso_59,
                          exp_size_60, con_size_61, empty_62, segs_63]) ->
              ErlangTuple
                [ErlangAtom "set", record_updt_42, n_8, maxn_58, bso_59,
                 record_updt_49, record_updt_52, empty_62, segs2_40]
            _ -> EXC.badrecord (ErlangAtom "set")
      _ -> EXC.badmatch matchExpr_32
erlps__maybe_expand__1 [t_0] =
  let   
    lop_3 =
      case t_0 of
        (ErlangTuple arr_6) | (DM.Just field_5) <- (arr_6 DA.!! 1) ->
          field_5
        _ -> EXC.badrecord (ErlangAtom "set")
  in let rop_7 = toErl 1
  in let record_updt_2 = BIF.erlang__op_plus [lop_3, rop_7]
  in
    case t_0 of
      (ErlangTuple [(ErlangAtom "set"), size_8, n_9, maxn_10, bso_11,
                    exp_size_12, con_size_13, empty_14, segs_15]) ->
        ErlangTuple
          [ErlangAtom "set", record_updt_2, n_9, maxn_10, bso_11,
           exp_size_12, con_size_13, empty_14, segs_15]
      _ -> EXC.badrecord (ErlangAtom "set")
erlps__maybe_expand__1 [arg_16] = EXC.function_clause unit
erlps__maybe_expand__1 args =
  EXC.badarity (ErlangFun 1 erlps__maybe_expand__1) args

erlps__maybe_expand_segs__1 :: ErlangFun
erlps__maybe_expand_segs__1 [t_0]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let   
              lop_31 =
                case t_0 of
                  (ErlangTuple arr_34) | (DM.Just field_33) <-
                                           (arr_34 DA.!! 2) ->
                    field_33
                  _ -> EXC.badrecord (ErlangAtom "set")
            in let
              rop_35 =
                case t_0 of
                  (ErlangTuple arr_38) | (DM.Just field_37) <-
                                           (arr_38 DA.!! 3) ->
                    field_37
                  _ -> EXC.badrecord (ErlangAtom "set")
            in BIF.erlang__op_exactEq [lop_31, rop_35])) =
  let    lop_3 = toErl 2
  in let
    rop_4 =
      case t_0 of
        (ErlangTuple arr_7) | (DM.Just field_6) <- (arr_7 DA.!! 3) ->
          field_6
        _ -> EXC.badrecord (ErlangAtom "set")
  in let record_updt_2 = BIF.erlang__op_mult [lop_3, rop_4]
  in let lop_9 = toErl 2
  in let
    rop_10 =
      case t_0 of
        (ErlangTuple arr_13) | (DM.Just field_12) <- (arr_13 DA.!! 4) ->
          field_12
        _ -> EXC.badrecord (ErlangAtom "set")
  in let record_updt_8 = BIF.erlang__op_mult [lop_9, rop_10]
  in let
    arg_15 =
      case t_0 of
        (ErlangTuple arr_18) | (DM.Just field_17) <- (arr_18 DA.!! 8) ->
          field_17
        _ -> EXC.badrecord (ErlangAtom "set")
  in let
    arg_19 =
      case t_0 of
        (ErlangTuple arr_22) | (DM.Just field_21) <- (arr_22 DA.!! 7) ->
          field_21
        _ -> EXC.badrecord (ErlangAtom "set")
  in let record_updt_14 = erlps__expand_segs__2 [arg_15, arg_19]
  in
    case t_0 of
      (ErlangTuple [(ErlangAtom "set"), size_23, n_24, maxn_25, bso_26,
                    exp_size_27, con_size_28, empty_29, segs_30]) ->
        ErlangTuple
          [ErlangAtom "set", size_23, n_24, record_updt_2, record_updt_8,
           exp_size_27, con_size_28, empty_29, record_updt_14]
      _ -> EXC.badrecord (ErlangAtom "set")
erlps__maybe_expand_segs__1 [t_0] = t_0
erlps__maybe_expand_segs__1 [arg_1] = EXC.function_clause unit
erlps__maybe_expand_segs__1 args =
  EXC.badarity (ErlangFun 1 erlps__maybe_expand_segs__1) args

erlps__maybe_contract__2 :: ErlangFun
erlps__maybe_contract__2 [t_0, dc_1]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let   
              lop_62 =
                case t_0 of
                  (ErlangTuple arr_65) | (DM.Just field_64) <-
                                           (arr_65 DA.!! 1) ->
                    field_64
                  _ -> EXC.badrecord (ErlangAtom "set")
            in let lop_61 = BIF.erlang__op_minus [lop_62, dc_1]
            in let
              rop_67 =
                case t_0 of
                  (ErlangTuple arr_70) | (DM.Just field_69) <-
                                           (arr_70 DA.!! 6) ->
                    field_69
                  _ -> EXC.badrecord (ErlangAtom "set")
            in let lop_60 = BIF.erlang__op_lesser [lop_61, rop_67]
            in
              case lop_60 of
                (ErlangAtom "false") -> ErlangAtom "false"
                (ErlangAtom "true") ->
                  let   
                    lop_71 =
                      case t_0 of
                        (ErlangTuple arr_74) | (DM.Just field_73) <-
                                                 (arr_74 DA.!! 2) ->
                          field_73
                        _ -> EXC.badrecord (ErlangAtom "set")
                  in let rop_75 = toErl 16
                  in BIF.erlang__op_greater [lop_71, rop_75]
                _ -> EXC.badarg1 lop_60)) =
  let   
    n_5 =
      case t_0 of
        (ErlangTuple arr_4) | (DM.Just field_3) <- (arr_4 DA.!! 2) ->
          field_3
        _ -> EXC.badrecord (ErlangAtom "set")
  in let
    rop_7 =
      case t_0 of
        (ErlangTuple arr_10) | (DM.Just field_9) <- (arr_10 DA.!! 4) ->
          field_9
        _ -> EXC.badrecord (ErlangAtom "set")
  in let slot1_11 = BIF.erlang__op_minus [n_5, rop_7]
  in let
    segs0_15 =
      case t_0 of
        (ErlangTuple arr_14) | (DM.Just field_13) <- (arr_14 DA.!! 8) ->
          field_13
        _ -> EXC.badrecord (ErlangAtom "set")
  in let b1_18 = erlps__get_bucket_s__2 [segs0_15, slot1_11]
  in let b2_22 = erlps__get_bucket_s__2 [segs0_15, n_5]
  in let arg_25 = BIF.erlang__op_append [b1_18, b2_22]
  in let
    segs1_28 = erlps__put_bucket_s__3 [segs0_15, slot1_11, arg_25]
  in let
    segs2_32 =
      erlps__put_bucket_s__3 [segs1_28, n_5, ErlangEmptyList]
  in let rop_34 = toErl 1
  in let n1_35 = BIF.erlang__op_minus [n_5, rop_34]
  in let
    lop_39 =
      case t_0 of
        (ErlangTuple arr_42) | (DM.Just field_41) <- (arr_42 DA.!! 1) ->
          field_41
        _ -> EXC.badrecord (ErlangAtom "set")
  in let record_updt_38 = BIF.erlang__op_minus [lop_39, dc_1]
  in let rop_47 = toErl 5
  in let record_updt_45 = BIF.erlang__op_mult [n1_35, rop_47]
  in let rop_50 = toErl 3
  in let record_updt_48 = BIF.erlang__op_mult [n1_35, rop_50]
  in let
    arg_36 =
      case t_0 of
        (ErlangTuple [(ErlangAtom "set"), size_52, n_53, maxn_54, bso_55,
                      exp_size_56, con_size_57, empty_58, segs_59]) ->
          ErlangTuple
            [ErlangAtom "set", record_updt_38, n1_35, maxn_54, bso_55,
             record_updt_45, record_updt_48, empty_58, segs2_32]
        _ -> EXC.badrecord (ErlangAtom "set")
  in erlps__maybe_contract_segs__1 [arg_36]
erlps__maybe_contract__2 [t_0, dc_1] =
  let   
    lop_4 =
      case t_0 of
        (ErlangTuple arr_7) | (DM.Just field_6) <- (arr_7 DA.!! 1) ->
          field_6
        _ -> EXC.badrecord (ErlangAtom "set")
  in let record_updt_3 = BIF.erlang__op_minus [lop_4, dc_1]
  in
    case t_0 of
      (ErlangTuple [(ErlangAtom "set"), size_9, n_10, maxn_11, bso_12,
                    exp_size_13, con_size_14, empty_15, segs_16]) ->
        ErlangTuple
          [ErlangAtom "set", record_updt_3, n_10, maxn_11, bso_12,
           exp_size_13, con_size_14, empty_15, segs_16]
      _ -> EXC.badrecord (ErlangAtom "set")
erlps__maybe_contract__2 [arg_17, arg_18] =
  EXC.function_clause unit
erlps__maybe_contract__2 args =
  EXC.badarity (ErlangFun 2 erlps__maybe_contract__2) args

erlps__maybe_contract_segs__1 :: ErlangFun
erlps__maybe_contract_segs__1 [t_0]
  | (ErlangAtom "true") ==
      (falsifyErrors
         (\ _ ->
            let   
              lop_27 =
                case t_0 of
                  (ErlangTuple arr_30) | (DM.Just field_29) <-
                                           (arr_30 DA.!! 2) ->
                    field_29
                  _ -> EXC.badrecord (ErlangAtom "set")
            in let
              rop_31 =
                case t_0 of
                  (ErlangTuple arr_34) | (DM.Just field_33) <-
                                           (arr_34 DA.!! 4) ->
                    field_33
                  _ -> EXC.badrecord (ErlangAtom "set")
            in BIF.erlang__op_exactEq [lop_27, rop_31])) =
  let   
    lop_3 =
      case t_0 of
        (ErlangTuple arr_6) | (DM.Just field_5) <- (arr_6 DA.!! 3) ->
          field_5
        _ -> EXC.badrecord (ErlangAtom "set")
  in let rop_7 = toErl 2
  in let record_updt_2 = BIF.erlang__op_div_strict [lop_3, rop_7]
  in let
    lop_9 =
      case t_0 of
        (ErlangTuple arr_12) | (DM.Just field_11) <- (arr_12 DA.!! 4) ->
          field_11
        _ -> EXC.badrecord (ErlangAtom "set")
  in let rop_13 = toErl 2
  in let record_updt_8 = BIF.erlang__op_div_strict [lop_9, rop_13]
  in let
    arg_15 =
      case t_0 of
        (ErlangTuple arr_18) | (DM.Just field_17) <- (arr_18 DA.!! 8) ->
          field_17
        _ -> EXC.badrecord (ErlangAtom "set")
  in let record_updt_14 = erlps__contract_segs__1 [arg_15]
  in
    case t_0 of
      (ErlangTuple [(ErlangAtom "set"), size_19, n_20, maxn_21, bso_22,
                    exp_size_23, con_size_24, empty_25, segs_26]) ->
        ErlangTuple
          [ErlangAtom "set", size_19, n_20, record_updt_2, record_updt_8,
           exp_size_23, con_size_24, empty_25, record_updt_14]
      _ -> EXC.badrecord (ErlangAtom "set")
erlps__maybe_contract_segs__1 [t_0] = t_0
erlps__maybe_contract_segs__1 [arg_1] = EXC.function_clause unit
erlps__maybe_contract_segs__1 args =
  EXC.badarity (ErlangFun 1 erlps__maybe_contract_segs__1) args

erlps__rehash__4 :: ErlangFun
erlps__rehash__4 [(ErlangCons e_0 t_1), slot1_2, slot2_3, maxn_4]
  =
  let
    matchExpr_11 = erlps__rehash__4 [t_1, slot1_2, slot2_3, maxn_4]
  in
    case matchExpr_11 of
      (ErlangTuple [l1_9, l2_10]) ->
        let case_12 = BIF.erlang__phash__2 [e_0, maxn_4]
        in
          case case_12 of
            slot1_15 | slot1_15 == slot1_2 ->
              ErlangTuple [ErlangCons e_0 l1_9, l2_10]
            slot2_20 | slot2_20 == slot2_3 ->
              ErlangTuple [l1_9, ErlangCons e_0 l2_10]
            something_else -> EXC.case_clause something_else
      _ -> EXC.badmatch matchExpr_11
erlps__rehash__4 [(ErlangEmptyList), _, _, _] =
  ErlangTuple [ErlangEmptyList, ErlangEmptyList]
erlps__rehash__4 [arg_2, arg_3, arg_4, arg_5] =
  EXC.function_clause unit
erlps__rehash__4 args =
  EXC.badarity (ErlangFun 4 erlps__rehash__4) args

erlps__mk_seg__1 :: ErlangFun
erlps__mk_seg__1 [(ErlangInt num_0)]
  | (ErlangInt num_0) == (toErl 16) =
  ErlangTuple
    [ErlangEmptyList, ErlangEmptyList, ErlangEmptyList,
     ErlangEmptyList, ErlangEmptyList, ErlangEmptyList,
     ErlangEmptyList, ErlangEmptyList, ErlangEmptyList,
     ErlangEmptyList, ErlangEmptyList, ErlangEmptyList,
     ErlangEmptyList, ErlangEmptyList, ErlangEmptyList,
     ErlangEmptyList]
erlps__mk_seg__1 [arg_17] = EXC.function_clause unit
erlps__mk_seg__1 args =
  EXC.badarity (ErlangFun 1 erlps__mk_seg__1) args

erlps__expand_segs__2 :: ErlangFun
erlps__expand_segs__2 [(ErlangTuple [b1_0]), empty_1] =
  ErlangTuple [b1_0, empty_1]
erlps__expand_segs__2 [(ErlangTuple [b1_0, b2_1]), empty_2] =
  ErlangTuple [b1_0, b2_1, empty_2, empty_2]
erlps__expand_segs__2 [(ErlangTuple [b1_0, b2_1, b3_2, b4_3]),
                       empty_4]
  =
  ErlangTuple
    [b1_0, b2_1, b3_2, b4_3, empty_4, empty_4, empty_4, empty_4]
erlps__expand_segs__2 [(ErlangTuple [b1_0, b2_1, b3_2, b4_3,
                                     b5_4, b6_5, b7_6, b8_7]),
                       empty_8]
  =
  ErlangTuple
    [b1_0, b2_1, b3_2, b4_3, b5_4, b6_5, b7_6, b8_7, empty_8,
     empty_8, empty_8, empty_8, empty_8, empty_8, empty_8, empty_8]
erlps__expand_segs__2 [(ErlangTuple [b1_0, b2_1, b3_2, b4_3,
                                     b5_4, b6_5, b7_6, b8_7, b9_8, b10_9,
                                     b11_10, b12_11, b13_12, b14_13, b15_14,
                                     b16_15]),
                       empty_16]
  =
  ErlangTuple
    [b1_0, b2_1, b3_2, b4_3, b5_4, b6_5, b7_6, b8_7, b9_8, b10_9,
     b11_10, b12_11, b13_12, b14_13, b15_14, b16_15, empty_16,
     empty_16, empty_16, empty_16, empty_16, empty_16, empty_16,
     empty_16, empty_16, empty_16, empty_16, empty_16, empty_16,
     empty_16, empty_16, empty_16]
erlps__expand_segs__2 [segs_0, empty_1] =
  let    lop_3 = BIF.erlang__tuple_to_list__1 [segs_0]
  in let arg_6 = BIF.erlang__tuple_size__1 [segs_0]
  in let
    rop_5 =
      BIF.do_remote_fun_call "Lists" "erlps__duplicate__2"
        [arg_6, empty_1]
  in let arg_2 = BIF.erlang__op_append [lop_3, rop_5]
  in BIF.erlang__list_to_tuple__1 [arg_2]
erlps__expand_segs__2 [arg_9, arg_10] = EXC.function_clause unit
erlps__expand_segs__2 args =
  EXC.badarity (ErlangFun 2 erlps__expand_segs__2) args

erlps__contract_segs__1 :: ErlangFun
erlps__contract_segs__1 [(ErlangTuple [b1_0, _])] =
  ErlangTuple [b1_0]
erlps__contract_segs__1 [(ErlangTuple [b1_0, b2_1, _, _])] =
  ErlangTuple [b1_0, b2_1]
erlps__contract_segs__1 [(ErlangTuple [b1_0, b2_1, b3_2, b4_3, _,
                                       _, _, _])]
  =
  ErlangTuple [b1_0, b2_1, b3_2, b4_3]
erlps__contract_segs__1 [(ErlangTuple [b1_0, b2_1, b3_2, b4_3,
                                       b5_4, b6_5, b7_6, b8_7, _, _, _, _, _, _,
                                       _, _])]
  =
  ErlangTuple [b1_0, b2_1, b3_2, b4_3, b5_4, b6_5, b7_6, b8_7]
erlps__contract_segs__1 [(ErlangTuple [b1_0, b2_1, b3_2, b4_3,
                                       b5_4, b6_5, b7_6, b8_7, b9_8, b10_9,
                                       b11_10, b12_11, b13_12, b14_13, b15_14,
                                       b16_15, _, _, _, _, _, _, _, _, _, _, _,
                                       _, _, _, _, _])]
  =
  ErlangTuple
    [b1_0, b2_1, b3_2, b4_3, b5_4, b6_5, b7_6, b8_7, b9_8, b10_9,
     b11_10, b12_11, b13_12, b14_13, b15_14, b16_15]
erlps__contract_segs__1 [segs_0] =
  let    lop_1 = BIF.erlang__tuple_size__1 [segs_0]
  in let rop_3 = toErl 2
  in let ss_4 = BIF.erlang__op_div_strict [lop_1, rop_3]
  in let arg_6 = BIF.erlang__tuple_to_list__1 [segs_0]
  in let arg_8 = toErl 1
  in let
    arg_5 =
      BIF.do_remote_fun_call "Lists" "erlps__sublist__3"
        [arg_6, arg_8, ss_4]
  in BIF.erlang__list_to_tuple__1 [arg_5]
erlps__contract_segs__1 [arg_10] = EXC.function_clause unit
erlps__contract_segs__1 args =
  EXC.badarity (ErlangFun 1 erlps__contract_segs__1) args